import re, math, os
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import streamlit as st
import oracledb
from datetime import date

# =========================
#  CONFIG: ORACLE / POSTGRES
# =========================
HOST = st.secrets.get("ORACLE_HOST", os.getenv("ORACLE_HOST", "34.134.141.229"))
PORT = int(st.secrets.get("ORACLE_PORT", os.getenv("ORACLE_PORT", "1522")))
SID  = st.secrets.get("ORACLE_SID",  os.getenv("ORACLE_SID",  "DESA2"))
USER = st.secrets.get("ORACLE_USER", os.getenv("ORACLE_USER", "HUB_USER"))
PWD  = st.secrets.get("ORACLE_PWD",  os.getenv("ORACLE_PWD",  ""))

PG_HOST = st.secrets.get("PG_HOST", os.getenv("PG_HOST", "34.134.141.229"))
PG_PORT = int(st.secrets.get("PG_PORT", os.getenv("PG_PORT", "6543")))
PG_DB   = st.secrets.get("PG_DB",   os.getenv("PG_DB",   "columbus_databroker_prod"))
PG_USER = st.secrets.get("PG_USER", os.getenv("PG_USER", "columbus_databroker_user"))
PG_PWD  = st.secrets.get("PG_PWD",  os.getenv("PG_PWD",  ""))

DEFAULT_ALIAS   = st.secrets.get("DEFAULT_ALIAS", os.getenv("DEFAULT_ALIAS", "UNIB"))
DEFAULT_INFL    = float(st.secrets.get("INFLACION_ANUAL", os.getenv("INFLACION_ANUAL", "0.035")))

# Productos de reporto que deben contabilizarse como RV
REPORTO_RV_PRODUCTS = [144, 149]
REPORTO_RV_CSV = ",".join(str(i) for i in REPORTO_RV_PRODUCTS)

# =========================
#  PAGE + CSS
# =========================
st.set_page_config(page_title="Reportes Institucionales", layout="wide")

def css_global():
    return """
    <style>

    /* Fuentes (deployment Streamlit mantiene diseño) */
    @import url('https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Nunito+Sans:wght@300;400;600;700&display=swap');

    :root{
      --bg1:#f8fafc; --bg2:#e5e7eb;
      --ink:#0f172a; --ink-weak:#334155;
      --cardbg: rgba(0,0,0,.03); --cardbd: rgba(0,0,0,.08);
    }

    html, body, .stApp{
      font-family:'Nunito Sans', sans-serif !important;
      color:var(--ink);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
    }

    h1, h2, h3 {
      font-family:'DM Serif Display', serif !important;
    }

    header[data-testid="stHeader"]{
      background:#ffffff;
      color:var(--ink);
      border-bottom:1px solid var(--cardbd);
    }
    section[data-testid="stSidebar"]{
      color: var(--ink);
      background:#ffffff;
      border-right: 1px solid var(--cardbd);
    }

    .sb-card{
      background: var(--cardbg);
      border:1px solid var(--cardbd);
      border-radius: 14px;
      padding: 12px;
      margin: 8px 0;
    }
    .sb-title{
      font-size:.9rem;
      color:var(--ink);
      letter-spacing:.06em;
      text-transform:uppercase;
      margin-bottom:6px;
    }

    .kpi-grid{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:12px;
      margin: 6px 0 8px 0;
    }
    .kpi-card{
      background: linear-gradient(180deg, rgba(34,197,94,.10), rgba(2,6,23,.00));
      border:1px solid rgba(34,197,94,.25);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .kpi-label{
      font-size:.72rem;
      color:var(--ink-weak);
      letter-spacing:.06em;
      text-transform:uppercase;
    }
    .kpi-value{
      font-size:1.25rem;
      font-weight:800;
      color:var(--ink);
      margin-top:2px;
    }

    .chip{
      display:inline-block;
      padding:.24rem .52rem;
      border-radius:999px;
      margin:2px 6px 8px 0;
      background:linear-gradient(90deg, rgba(124,58,237,.18), rgba(34,211,238,.16));
      border:1px solid rgba(124,58,237,.35);
      font-size:.84rem;
      color:var(--ink);
    }

    .chip-date{
      display:inline-block;
      padding:.24rem .52rem;
      border-radius:999px;
      margin:2px 6px 8px 0;
      background:rgba(30,58,138,.08);
      border:1px solid rgba(30,58,138,.55);
      font-size:.84rem;
      color:#1e3a8a;
      font-weight:600;
    }

    /* =========================
       TABLAS EN PANTALLA
       ========================= */

    /* Encabezados centrados en st.dataframe */
    [data-testid="stDataFrame"] div[role="columnheader"],
    [data-testid="stDataFrame"] div[role="columnheader"] *{
      text-align: center !important;
      justify-content: center !important;
      align-items: center !important;
    }

    /* Celdas y encabezados (todas las tablas st.dataframe en pantalla) */
    [data-testid="stDataFrame"] div[role="gridcell"],
    [data-testid="stDataFrame"] div[role="columnheader"]{
      font-size: 12px !important;
      line-height: 1.3 !important;
      padding: 4px 8px !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }

    /* Tablas HTML generadas por pandas (tiny_table_print, etc.) */
    table.dataframe th,
    table.dataframe td{
      text-align: center !important;
      padding: 4px 8px !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      font-size: 11px !important;
    }

    /* TABLA DETALLE DEUDA — compacta (se mantiene igual) */
    .deuda-detail-table [data-testid="stDataFrame"] div[role="columnheader"],
    .deuda-detail-table [data-testid="stDataFrame"] div[role="gridcell"]{
      font-size: 8px !important;
      line-height: 1.05 !important;
      padding: 1px 3px !important;
    }

    /* TABLA DEUDA RESUMEN (semaforo de riesgo) compacta */
    .deuda-resumen-table table,
    .deuda-resumen-table table.dataframe{
      border-collapse: collapse !important;
      width: auto !important;
    }
    .deuda-resumen-table th,
    .deuda-resumen-table td{
      font-size: 9px !important;
      padding: 2px 4px !important;
      text-align: center !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }

    /* Clase para forzar salto de página explícito */
    @media print {
      .page-break-after{
        page-break-after: always;
      }
    }

    /* =========================
       VISTA IMPRESIÓN
       ========================= */
    @media print {
      @page { size: letter landscape; margin: 0.45in; }
      body, .stApp{
        background:#ffffff !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      [data-testid="stSidebar"],
      [data-testid="stToolbar"],
      [data-testid="stStatusWidget"]{
        display: none !important;
      }

      .tabs-normal { display: none !important; }
      .print-container { display: block !important; }
      .block-container { padding: 0 !important; }

      h1, h2, h3{
        margin-top: 0.25in !important;
        page-break-after: avoid;
        page-break-before: avoid;
      }

      .element-container,
      .plotly,
      .stPlotlyChart,
      [data-testid="stDataFrame"]{
        break-inside: avoid;
      }

      /* TABLAS st.dataframe en impresión: fuente 18 */
      [data-testid="stDataFrame"]{
        page-break-after: always !important;
        break-after: always !important;
      }

      [data-testid="stDataFrame"] div[role="columnheader"],
      [data-testid="stDataFrame"] div[role="gridcell"]{
        font-size: 18px !important;
        line-height: 1.2 !important;
        padding: 4px 8px !important;
        text-align: center !important;
        justify-content: center !important;
        align-items: center !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
      }

      /* Tablas HTML (tiny_table_print) en impresión: fuente 18 + salto de página */
      .table-print{
        page-break-after: always !important;
        break-after: always !important;
      }

      .table-print table.dataframe th,
      .table-print table.dataframe td{
        font-size: 18px !important;
        line-height: 1.2 !important;
        padding: 4px 8px !important;
        text-align: center !important;
        white-space: nowrap !important;
        overflow: hidden !important;
        text-overflow: ellipsis !important;
      }

      /* DETALLE DEUDA — se mantiene compacto también al imprimir */
      .deuda-detail-table [data-testid="stDataFrame"] div[role="columnheader"],
      .deuda-detail-table [data-testid="stDataFrame"] div[role="gridcell"]{
        font-size: 8px !important;
        line-height: 1.0 !important;
        padding: 1px 3px !important;
      }

      /* TABLA DEUDA RESUMEN compacta al imprimir (solo tamaño, sin romper la lógica anterior) */
      .deuda-resumen-table th,
      .deuda-resumen-table td{
        font-size: 9px !important;
        padding: 2px 3px !important;
      }

      /* OCULTAR SELECTORES EN IMPRESIÓN */
      [data-testid="stWidget"],
      [data-testid="stSelectbox"],
      [data-testid="stMultiSelect"],
      [data-testid="stRadio"],
      [data-testid="stSlider"],
      [data-testid="stDateInput"],
      [data-testid="stNumberInput"],
      [data-testid="stTextInput"],
      [data-testid="stForm"],
      .stSelectbox,
      .stMultiSelect,
      .stRadio,
      .stSlider,
      .stDateInput,
      .stNumberInput,
      .stTextInput,
      [role="radiogroup"],
      [role="combobox"],
      input[type="checkbox"],
      input[type="radio"],
      select,
      textarea{
        display: none !important;
      }

      .page-break {
        page-break-after: always !important;
        break-after: always !important;
      }

      /* Cada sección de pestaña grande (AA, Deuda, RV) en página nueva */
      .print-section{
        page-break-before: always !important;
        break-before: always !important;
      }
    }

    </style>
    """

st.markdown(css_global(), unsafe_allow_html=True)

# Helper para tablas mini en impresión (con bordes + salto de página al final)
def tiny_table_print(df: pd.DataFrame):
    html = df.to_html(index=False, border=0, classes="dataframe")
    st.markdown(f'<div class="table-print">{html}</div>', unsafe_allow_html=True)


# =========================
#  SIDEBAR (parámetros)
# =========================
with st.sidebar:
    st.markdown('<div class="sb-card"><div class="sb-title">Parámetros</div>', unsafe_allow_html=True)
    ALIAS_CDM = st.text_input("Cliente (ALIAS_CDM)", value=DEFAULT_ALIAS)
    hoy = date.today()
    coly, colm = st.columns(2)
    with coly:
        y = st.number_input("Año", 2000, 2100, hoy.year, step=1)
    with colm:
        m = st.number_input("Mes", 1, 12, hoy.month, step=1)
    INFLACION_ANUAL = st.number_input("Inflación anual (dec)", 0.0, 1.0, DEFAULT_INFL, 0.001, format="%.3f")
    st.markdown('</div>', unsafe_allow_html=True)

    st.markdown('<div class="sb-card"><div class="sb-title">Impresión</div>', unsafe_allow_html=True)
    print_mode = st.checkbox("Vista de impresión (Carta horizontal)", value=False)
    st.markdown('</div>', unsafe_allow_html=True)

# =========================
#  FECHAS Y CONSTANTES VISUALES
# =========================
F_DIA_INI = pd.Timestamp(year=y, month=m, day=1)
F_DIA_FIN = F_DIA_INI + pd.offsets.MonthEnd(1)
F_DIA_FIN_NEXT = F_DIA_FIN + pd.Timedelta(days=1)
FECHA_ESTADISTICA = F_DIA_FIN.strftime("%Y-%m-%d")

CHART_H = 360
BARH_H  = 320
TICKANGLE = 0 if print_mode else 45
LEGEND_RIGHT = dict(orientation="v", yanchor="top", y=1.0, xanchor="left", x=1.02)

# =========================
#  CONEXIONES / HELPERS
# =========================
def get_conn():
    if not PWD:
        raise RuntimeError("Falta ORACLE_PWD en secrets o variable de entorno.")
    dsn = oracledb.makedsn(HOST, PORT, sid=SID)
    oracledb.defaults.arraysize = 1000
    oracledb.defaults.prefetchrows = 1000
    return oracledb.connect(user=USER, password=PWD, dsn=dsn)

@st.cache_data(ttl=600, show_spinner=True)
def run_sql(sql: str, params: dict | None = None) -> pd.DataFrame:
    conn = get_conn()
    return pd.read_sql(sql, conn, params=params or {})

@st.cache_data(ttl=600, show_spinner=True)
def pg_run_sql(sql: str, params: dict | None = None) -> pd.DataFrame:
    import psycopg2
    from psycopg2 import OperationalError
    try:
        conn = psycopg2.connect(host=PG_HOST, port=PG_PORT, database=PG_DB, user=PG_USER, password=PG_PWD)
    except OperationalError as e:
        raise RuntimeError(f"Error PG: {e}")
    try:
        df = pd.read_sql(sql, conn, params=params or {})
    finally:
        conn.close()
    return df

def money_to_float_series(serie: pd.Series) -> pd.Series:
    if pd.api.types.is_numeric_dtype(serie):
        return serie.astype(float).fillna(0.0)
    s = serie.astype(str).str.replace('−', '-', regex=False)
    s = s.str.replace(r'[^\d\.,\-]+', '', regex=True).str.replace(',', '', regex=False)
    return pd.to_numeric(s, errors='coerce').fillna(0.0)

def fmt_pct(x):    return "—" if pd.isna(x) else f"{x*100:.2f}%"
def fmt_money2(x): return f"${x:,.2f}"
def fmt_mm(x):     return f"{x/1e6:.2f} MM"

CASE_ACTIVO = f"""
  CASE 
    WHEN e.ID_PRODUCTO IN ({REPORTO_RV_CSV}) THEN 'Renta Variable'
    ELSE CASE e.ID_TIPO_ACTIVO
      WHEN 0 THEN 'No aplica'
      WHEN 1 THEN 'Deuda'
      WHEN 2 THEN 'Renta Variable'
      WHEN 3 THEN 'Notas Estructuradas'
      WHEN 4 THEN 'Alternativo'
      WHEN 5 THEN 'Productos'
      WHEN 6 THEN 'Todos los Activos'
      WHEN 7 THEN 'Derivados'
      ELSE 'Desconocido'
    END
  END
"""

# =========================
#  UTILIDADES EXTRA
# =========================
@st.cache_data(ttl=900, show_spinner=True)
def get_num_contratos(alias: str) -> int:
    q = """SELECT COUNT(DISTINCT ID_CLIENTE) AS N FROM SIAPII.V_M_CONTRATO_CDM WHERE ALIAS_CDM = :a"""
    df = run_sql(q, {"a": alias})
    return int(df.iloc[0,0]) if not df.empty else 0

def _col_exists(owner:str, table:str, col:str) -> bool:
    q = """
    SELECT COUNT(*) AS N
    FROM ALL_TAB_COLUMNS
    WHERE OWNER = :o AND TABLE_NAME = :t AND COLUMN_NAME = :c
    """
    df = run_sql(q, {"o": owner.upper(), "t": table.upper(), "c": col.upper()})
    return (not df.empty) and (int(df.iloc[0,0]) > 0)

def _to_dec(x):
    if pd.isna(x): return np.nan
    s = str(x).strip().replace('%','').replace(' ','')
    if s.count(',') == 1 and s.count('.') == 0:
        s = s.replace(',', '.')
    s = re.sub(r'(?<=\d),(?=\d{3}\b)', '', s)
    try:
        v = float(s)
        return v if 0 <= v <= 1 else v/100.0
    except:
        return np.nan

# =========================
#  Rendimientos contrato 12m
# =========================
@st.cache_data(ttl=900, show_spinner=True)
def rend_bruto_contrato_hist_12m(alias: str, anio: int, mes: int) -> pd.DataFrame:
    ref = pd.Timestamp(year=int(anio), month=int(mes), day=1)
    start = (ref - pd.DateOffset(months=11)).replace(day=1)
    end   = (ref + pd.offsets.MonthEnd(0))
    sql = """
    WITH CTS AS (
      SELECT ID_CLIENTE
      FROM SIAPII.V_M_CONTRATO_CDM
      WHERE ALIAS_CDM = :alias
    )
    SELECT
        r.ANIO,
        r.MES,
        r.TASA,
        r.TASA_ACUMULADO,
        r.TASA_EFECTIVA,
        r.TASA_EFECTIVA_ACUMULADO
    FROM SIAPII.V_RENDIMIENTO_CTO r
    JOIN CTS c ON c.ID_CLIENTE = r.ID_CLIENTE
    WHERE UPPER(r.TIPO_RENDIMIENTO) LIKE 'GESTION BRUTA'
      AND r.NIVEL = 'CONTRATO'
      AND TRUNC(TO_DATE(r.ANIO || '-' || LPAD(r.MES,2,'0') || '-01', 'YYYY-MM-DD'))
          BETWEEN TO_DATE(:d_ini,'YYYY-MM-DD') AND TO_DATE(:d_fin,'YYYY-MM-DD')
    """
    df = run_sql(sql, {
        "alias": alias,
        "d_ini": start.strftime("%Y-%m-%d"),
        "d_fin": end.strftime("%Y-%m-%d"),
    })
    if df.empty:
        return pd.DataFrame(columns=[
            "ANIO","MES",
            "TASA_M_ANUAL","TASA_ACUM_ANUAL",
            "TASA_M_EFEC","TASA_ACUM_EFEC"
        ])
    df = df.sort_values(["ANIO","MES"]).groupby(["ANIO","MES"], as_index=False).last()
    df["TASA_M_ANUAL"]    = df["TASA"].apply(_to_dec)
    df["TASA_ACUM_ANUAL"] = df["TASA_ACUMULADO"].apply(_to_dec)
    df["TASA_M_EFEC"]     = df["TASA_EFECTIVA"].apply(_to_dec)
    df["TASA_ACUM_EFEC"]  = df["TASA_EFECTIVA_ACUMULADO"].apply(_to_dec)
    return df[[
        "ANIO","MES",
        "TASA_M_ANUAL","TASA_ACUM_ANUAL",
        "TASA_M_EFEC","TASA_ACUM_EFEC"
    ]]

# =========================
#  Rendimientos por producto 12m (V_RENDIMIENTO_PROD)
# =========================
@st.cache_data(ttl=900, show_spinner=True)
def rend_bruto_producto_hist_12m(alias: str, anio: int, mes: int) -> pd.DataFrame:
    ref = pd.Timestamp(year=int(anio), month=int(mes), day=1)
    start = (ref - pd.DateOffset(months=11)).replace(day=1)
    end = (ref + pd.offsets.MonthEnd(0))
    tiene_nivel_prod = _col_exists('SIAPII', 'V_RENDIMIENTO_PROD', 'NIVEL_PRODUCTO')
    filtro_nivel = "AND r.NIVEL_PRODUCTO = 'SI'" if tiene_nivel_prod else ""
    has_idcdm_cto = _col_exists('SIAPII', 'V_M_CONTRATO_CDM', 'ID_CDM')
    has_idcdm_rp  = _col_exists('SIAPII', 'V_RENDIMIENTO_PROD', 'ID_CDM')
    if has_idcdm_cto and has_idcdm_rp:
        sql = f"""
        WITH CTS AS (
            SELECT DISTINCT ID_CDM
            FROM SIAPII.V_M_CONTRATO_CDM
            WHERE ALIAS_CDM = :alias
        )
        SELECT
            r.ANIO,
            r.MES,
            r.ID_PRODUCTO,
            COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION') AS PRODUCTO,
            r.TASA,
            r.TASA_EFECTIVA,
            r.TASA_ACUMULADO,
            r.TASA_EFECTIVA_ACUMULADO
        FROM SIAPII.V_RENDIMIENTO_PROD r
        JOIN CTS c
          ON c.ID_CDM = r.ID_CDM
        LEFT JOIN SIAPII.V_M_PRODUCTO p
          ON p.ID_PRODUCTO = r.ID_PRODUCTO
        WHERE UPPER(r.TIPO_RENDIMIENTO) = 'GESTION BRUTA'
          {filtro_nivel}
          AND TRUNC(TO_DATE(r.ANIO || '-' || LPAD(r.MES,2,'0') || '-01', 'YYYY-MM-DD'))
              BETWEEN TO_DATE(:d_ini,'YYYY-MM-DD') AND TO_DATE(:d_fin,'YYYY-MM-DD')
        """
    else:
        sql = f"""
        WITH PROD_ALIAS AS (
            SELECT DISTINCT e.ID_PRODUCTO
            FROM SIAPII.V_CLIENTE_ESTADISTICAS e
            JOIN SIAPII.V_M_CONTRATO_CDM c
              ON c.ID_CLIENTE = e.ID_CLIENTE
            WHERE c.ALIAS_CDM = :alias
        )
        SELECT
            r.ANIO,
            r.MES,
            r.ID_PRODUCTO,
            COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION') AS PRODUCTO,
            r.TASA,
            r.TASA_EFECTIVA,
            r.TASA_ACUMULADO,
            r.TASA_EFECTIVA_ACUMULADO
        FROM SIAPII.V_RENDIMIENTO_PROD r
        JOIN PROD_ALIAS pa
          ON pa.ID_PRODUCTO = r.ID_PRODUCTO
        LEFT JOIN SIAPII.V_M_PRODUCTO p
          ON p.ID_PRODUCTO = r.ID_PRODUCTO
        WHERE UPPER(r.TIPO_RENDIMIENTO) = 'GESTION BRUTA'
          {filtro_nivel}
          AND TRUNC(TO_DATE(r.ANIO || '-' || LPAD(r.MES,2,'0') || '-01', 'YYYY-MM-DD'))
              BETWEEN TO_DATE(:d_ini,'YYYY-MM-DD') AND TO_DATE(:d_fin,'YYYY-MM-DD')
        """
    df = run_sql(sql, {
        "alias": alias,
        "d_ini": start.strftime("%Y-%m-%d"),
        "d_fin": end.strftime("%Y-%m-%d"),
    })
    if df.empty:
        return pd.DataFrame(columns=[
            "ANIO","MES","ID_PRODUCTO","PRODUCTO",
            "TASA_M_ANUAL","TASA_ACUM_ANUAL",
            "TASA_M_EFEC","TASA_ACUM_EFEC"
        ])
    df = (
        df.sort_values(["ANIO", "MES", "ID_PRODUCTO"])
          .groupby(["ANIO", "MES", "ID_PRODUCTO", "PRODUCTO"], as_index=False)
          .last()
    )
    df["TASA_M_ANUAL"]    = df["TASA"].apply(_to_dec)
    df["TASA_M_EFEC"]     = df["TASA_EFECTIVA"].apply(_to_dec)
    df["TASA_ACUM_ANUAL"] = df["TASA_ACUMULADO"].apply(_to_dec)
    df["TASA_ACUM_EFEC"]  = df["TASA_EFECTIVA_ACUMULADO"].apply(_to_dec)
    return df[[
        "ANIO","MES","ID_PRODUCTO","PRODUCTO",
        "TASA_M_ANUAL","TASA_ACUM_ANUAL",
        "TASA_M_EFEC","TASA_ACUM_EFEC"
    ]]

def _annualize_from_effective(tef_dec, plazo_dias):
    tef = pd.to_numeric(pd.Series(tef_dec), errors='coerce')
    plazo = pd.to_numeric(pd.Series(plazo_dias), errors='coerce')
    mask = (plazo > 0)
    out = pd.Series(np.nan, index=tef.index, dtype=float)
    out[mask] = (1.0 + tef[mask])**(360.0/plazo[mask]) - 1.0
    return out

@st.cache_data(ttl=900, show_spinner=True)
def rend_bruto_contrato_y_producto(alias: str, anio: int, mes: int):
    ids = run_sql("""
        SELECT ID_CLIENTE FROM SIAPII.V_M_CONTRATO_CDM
        WHERE ALIAS_CDM = :alias
    """, {"alias": alias})
    if ids.empty:
        return np.nan, np.nan, pd.DataFrame(columns=["Producto","Mensual Anualizado","Acum Anualizado"])
    has_id_producto = _col_exists('SIAPII','V_RENDIMIENTO_CTO','ID_PRODUCTO')
    has_desc_producto = _col_exists('SIAPII','V_RENDIMIENTO_CTO','DESCRIPCION_PRODUCTO')
    sel_cols = """
        r.ANIO, r.MES, r.ID_CDM, r.ID_CLIENTE,
        r.MODALIDAD, r.NIVEL, r.PERIODO, r.MONEDA_ORIGEN, r.NIVEL_PRODUCTO,
        r.TIPO_RENDIMIENTO,
        r.TASA_EFECTIVA, r.PLAZO,
        r.TASA_EFECTIVA_ACUMULADO, r.PLAZO_ACUMULADO
    """
    if has_id_producto:
        sel_cols += ", r.ID_PRODUCTO"
    if has_desc_producto:
        sel_cols += ", r.DESCRIPCION_PRODUCTO"
    base_sql = f"""
        WITH CTS AS (
          SELECT ID_CLIENTE FROM SIAPII.V_M_CONTRATO_CDM WHERE ALIAS_CDM = :alias
        )
        SELECT {sel_cols}
        FROM SIAPII.V_RENDIMIENTO_CTO r
        JOIN CTS c ON c.ID_CLIENTE = r.ID_CLIENTE
        WHERE r.ANIO = :anio
          AND r.MES  = :mes
          AND UPPER(r.TIPO_RENDIMIENTO) LIKE 'GESTION BRUTA'
    """
    df = run_sql(base_sql, {"alias": alias, "anio": int(anio), "mes": int(mes)})
    if df.empty:
        return np.nan, np.nan, pd.DataFrame(columns=["Producto","Mensual Anualizado","Acum Anualizado"])
    df_cto = df[df["NIVEL"].astype(str).str.upper()=="CONTRATO"].copy()
    if not df_cto.empty:
        df_cto_m = df_cto.dropna(subset=["TASA_EFECTIVA","PLAZO"]).head(1)
        cto_m_anual = _annualize_from_effective(_to_dec(df_cto_m["TASA_EFECTIVA"].iloc[0]),
                                                df_cto_m["PLAZO"].iloc[0]).iloc[0]
        if df_cto.dropna(subset=["TASA_EFECTIVA_ACUMULADO","PLAZO_ACUMULADO"]).empty:
            cto_ytd_anual = np.nan
        else:
            row = df_cto.dropna(subset=["TASA_EFECTIVA_ACUMULADO","PLAZO_ACUMULADO"]).head(1).iloc[0]
            cto_ytd_anual = _annualize_from_effective(_to_dec(row["TASA_EFECTIVA_ACUMULADO"]),
                                                      row["PLAZO_ACUMULADO"]).iloc[0]
    else:
        cto_m_anual, cto_ytd_anual = np.nan, np.nan
    df_prod = pd.DataFrame(columns=["Producto","Mensual Anualizado","Acum Anualizado"])
    if has_id_producto or has_desc_producto:
        df_p = df[df["NIVEL_PRODUCTO"].astype(str).str.upper()=="SI"].copy()
        if not df_p.empty:
            if has_desc_producto:
                df_p["Producto"] = df_p["DESCRIPCION_PRODUCTO"].fillna("")
            elif has_id_producto:
                mp = run_sql("SELECT ID_PRODUCTO, COALESCE(DESCRIPCION,'SIN_DESCRIPCION') AS PRODUCTO FROM SIAPII.V_M_PRODUCTO")
                df_p = df_p.merge(mp, on="ID_PRODUCTO", how="left")
                df_p["Producto"] = df_p["PRODUCTO"].fillna(df_p.get("ID_PRODUCTO").astype(str))
            m_an = _annualize_from_effective(_to_dec(df_p["TASA_EFECTIVA"]), df_p["PLAZO"])
            a_an = _annualize_from_effective(_to_dec(df_p["TASA_EFECTIVA_ACUMULADO"]), df_p["PLAZO_ACUMULADO"])
            out = pd.DataFrame({
                "Producto": df_p["Producto"].astype(str),
                "Mensual Anualizado": (m_an*100.0).round(2),
                "Acum Anualizado": (a_an*100.0).round(2)
            })
            df_prod = (out.groupby("Producto", as_index=False)
                          .agg({"Mensual Anualizado":"last","Acum Anualizado":"last"})
                          .sort_values("Mensual Anualizado", ascending=False)
                          .reset_index(drop=True))
    return cto_m_anual, cto_ytd_anual, df_prod

# =========================
#  NOMBRE CLIENTE (título)
# =========================
@st.cache_data(ttl=3600, show_spinner=True)
def get_nombre_cliente(alias: str) -> str:
    sql = "SELECT NOMBRE_CLIENTE FROM SIAPII.V_M_CONTRATO_CDM WHERE ALIAS_CDM = :alias FETCH FIRST 1 ROWS ONLY"
    df = run_sql(sql, {"alias": alias})
    if df.empty or pd.isna(df.iloc[0,0]): return alias
    return str(df.iloc[0,0]).split(',', 1)[0].strip()

# =========================
#  BASE AA (corte)
# =========================
def build_query_base_unfiltered(alias: str, fecha: str) -> str:
    return f"""
    SELECT
      COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION') AS PRODUCTO,
      {CASE_ACTIVO} AS ACTIVO,
      SUM(e.POSICION_TOTAL) AS MONTO
    FROM SIAPII.V_CLIENTE_ESTADISTICAS e
    LEFT JOIN SIAPII.V_M_PRODUCTO p ON p.ID_PRODUCTO = e.ID_PRODUCTO
    WHERE e.ALIAS_CDM = :alias
      AND TRUNC(e.FECHA_ESTADISTICA) = TO_DATE(:fecha, 'YYYY-MM-DD')
    GROUP BY COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION'), {CASE_ACTIVO}
    """

@st.cache_data(ttl=3600, show_spinner=True)
def aa_hist_ultimo_5_anios(alias: str):
    SQL = f"""
    WITH A AS (
      SELECT
        EXTRACT(YEAR FROM TRUNC(e.FECHA_ESTADISTICA)) AS ANIO,
        {CASE_ACTIVO} AS ACTIVO,
        COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION') AS PRODUCTO,
        SUM(e.POSICION_TOTAL) AS MONTO
      FROM SIAPII.V_CLIENTE_ESTADISTICAS e
      JOIN SIAPII.V_M_CONTRATO_CDM c ON c.ID_CLIENTE = e.ID_CLIENTE AND c.ALIAS_CDM = :alias
      LEFT JOIN SIAPII.V_M_PRODUCTO p ON p.ID_PRODUCTO = e.ID_PRODUCTO
      WHERE e.FECHA_ESTADISTICA >= ADD_MONTHS(TRUNC(SYSDATE,'YYYY'), -12*5)
      GROUP BY EXTRACT(YEAR FROM TRUNC(e.FECHA_ESTADISTICA)), {CASE_ACTIVO}, COALESCE(p.DESCRIPCION, 'SIN_DESCRIPCION')
    )
    SELECT * FROM A
    """
    df = run_sql(SQL, {"alias": alias})
    if df.empty:
        return (pd.DataFrame(columns=["ANIO","ACTIVO","MONTO","Pct"]),
                pd.DataFrame(columns=["ANIO","PRODUCTO","MONTO","Pct"]))
    aa_activo = df.groupby(["ANIO","ACTIVO"], dropna=False)["MONTO"].sum().reset_index()
    tot = aa_activo.groupby("ANIO")["MONTO"].sum().rename("TOT")
    aa_activo = aa_activo.merge(tot, on="ANIO", how="left")
    aa_activo["Pct"] = (aa_activo["MONTO"] / aa_activo["TOT"] * 100).round(2)
    aa_activo = aa_activo.drop(columns=["TOT"])
    aa_producto = df.groupby(["ANIO","PRODUCTO"], dropna=False)["MONTO"].sum().reset_index()
    tot2 = aa_producto.groupby("ANIO")["MONTO"].sum().rename("TOT")
    aa_producto = aa_producto.merge(tot2, on="ANIO", how="left")
    aa_producto["Pct"] = (aa_producto["MONTO"] / aa_producto["TOT"] * 100).round(2)
    aa_producto = aa_producto.drop(columns=["TOT"])
    return aa_activo, aa_producto

# =========================
#  Snapshot Deuda (ID_TIPO_ACTIVO=1) + ratings/carry
# =========================
FALLBACK_IDS = [37, 3]
ids_csv = ",".join(str(i) for i in FALLBACK_IDS)
DTYPE_Q = """
SELECT DATA_TYPE
FROM ALL_TAB_COLUMNS
WHERE OWNER = 'SIAPII'
  AND TABLE_NAME = 'V_TASAS_REFERENCIA'
  AND COLUMN_NAME = 'FECHA'
"""

@st.cache_data(ttl=3600, show_spinner=True)
def build_snapshot_params(alias: str, f_ini: pd.Timestamp, f_fin_next: pd.Timestamp):
    params = {"alias_up": alias, "f_ini_dt": f_ini.strftime("%Y-%m-%d"), "f_fin_dt": f_fin_next.strftime("%Y-%m-%d")}
    dt = run_sql(DTYPE_Q).DATA_TYPE.iloc[0].strip().upper()
    if dt in ("DATE","TIMESTAMP","TIMESTAMP(6)","TIMESTAMP WITH TIME ZONE","TIMESTAMP WITH LOCAL TIME ZONE"):
        date_expr = "TRUNC(CAST(r.FECHA AS DATE))"
    else:
        date_expr = (
            "CASE\n"
            "  WHEN REGEXP_LIKE(r.FECHA,'^[0-9]{4}-[0-9]{2}-[0-9]{2}') THEN TRUNC(TO_DATE(SUBSTR(r.FECHA,1,10),'YYYY-MM-DD'))\n"
            "  WHEN REGEXP_LIKE(r.FECHA,'^[0-9]{2}/[0-9]{2}/[0-9]{4}') THEN TRUNC(TO_DATE(SUBSTR(r.FECHA,1,10),'DD/MM/YYYY'))\n"
            "  ELSE NULL\nEND"
        )
    return params, date_expr

def where_filters_for_his(alias: str) -> str:
    parts = ["c.ALIAS_CDM = :alias_up", "c.ID_CLIENTE = h.ID_CLIENTE"]
    return "WHERE EXISTS ( SELECT 1 FROM SIAPII.V_M_CONTRATO_CDM c WHERE " + " AND ".join(parts) + " )"

@st.cache_data(ttl=1200, show_spinner=True)
def query_snapshot_deuda(alias: str, f_ini: pd.Timestamp, f_fin_next: pd.Timestamp) -> pd.DataFrame:
    params, DATE_EXPR = build_snapshot_params(alias, f_ini, f_fin_next)
    where_exists = where_filters_for_his(alias)
    SQL_SNAPSHOT = f"""
WITH FECHA_C AS (
  SELECT MAX(TRUNC(h1.REGISTRO_CONTROL)) AS FECHA_CORTE
  FROM SIAPII.V_HIS_POSICION_CLIENTE h1
  WHERE TRUNC(h1.REGISTRO_CONTROL) >= TO_DATE(:f_ini_dt,'YYYY-MM-DD')
    AND TRUNC(h1.REGISTRO_CONTROL) <  TO_DATE(:f_fin_dt,'YYYY-MM-DD')
    AND EXISTS (SELECT 1 FROM SIAPII.V_M_CONTRATO_CDM c1 WHERE c1.ALIAS_CDM = :alias_up AND c1.ID_CLIENTE = h1.ID_CLIENTE)
),
H_CORTE AS (
  SELECT h.* FROM SIAPII.V_HIS_POSICION_CLIENTE h
  JOIN FECHA_C fc ON TRUNC(h.REGISTRO_CONTROL) = fc.FECHA_CORTE
  {where_exists}
),
VTR_NORM AS (
  SELECT r.ID_TASA_REFERENCIA, r.TASA_REFERENCIA, r.TASA, {DATE_EXPR} AS FECHA_TRUNC
  FROM SIAPII.V_TASAS_REFERENCIA r
),
VTR_EXACT AS (
  SELECT v.ID_TASA_REFERENCIA, v.TASA, v.TASA_REFERENCIA
  FROM VTR_NORM v CROSS JOIN FECHA_C fc
  WHERE v.FECHA_TRUNC = fc.FECHA_CORTE
),
VTR_FALL AS (
  SELECT x.ID_TASA_REFERENCIA, x.TASA, x.TASA_REFERENCIA FROM (
    SELECT v.ID_TASA_REFERENCIA, v.TASA, v.TASA_REFERENCIA, v.FECHA_TRUNC,
           ROW_NUMBER() OVER (PARTITION BY v.ID_TASA_REFERENCIA ORDER BY v.FECHA_TRUNC DESC) AS RN
    FROM VTR_NORM v CROSS JOIN FECHA_C fc
    WHERE v.ID_TASA_REFERENCIA IN ({ids_csv})
      AND v.FECHA_TRUNC IS NOT NULL AND v.FECHA_TRUNC <= fc.FECHA_CORTE
  ) x WHERE x.RN = 1
),
VTR_REF AS (
  SELECT e.ID_TASA_REFERENCIA, e.TASA, e.TASA_REFERENCIA
  FROM VTR_EXACT e
  UNION ALL
  SELECT f.ID_TASA_REFERENCIA, f.TASA, f.TASA_REFERENCIA
  FROM VTR_FALL f
  WHERE NOT EXISTS (SELECT 1 FROM VTR_EXACT e WHERE e.ID_TASA_REFERENCIA = f.ID_TASA_REFERENCIA)
)
SELECT
    h.ID_PRODUCTO, e.ID_EMISORA,
    MAX(e.NOMBRE_EMISORA)           AS NOMBRE_EMISORA,
    MAX(e.SERIE)                    AS SERIE,
    MAX(e.TIPO_PAPEL)               AS TIPO_PAPEL,
    MAX(e.TIPO_INSTRUMENTO)         AS TIPO_INSTRUMENTO,
    MAX(e.PLAZO_CUPON)              AS PLAZO_CUPON,
    MAX(e.FECHA_VTO_EM)             AS FECHA_VTO_EM,
    MAX(e.ID_TASA_REFERENCIA)       AS ID_TASA_REFERENCIA,
    MAX(e.ID_DIVISA_TV)             AS ID_DIVISA_TV,
    MAX(h.CALIFICACION_HOMOLOGADA)  AS CALIFICACION_HOMOLOGADA,
    MAX(h.CALIFICACION_S_P)         AS CALIFICACION_S_P,
    MAX(h.CALIFICACION_MDYS)        AS CALIFICACION_MDYS,
    MAX(h.CALIFICACION_HRRATING)    AS CALIFICACION_HRRATING,
    MAX(h.CALIFICACION_FITCH)       AS CALIFICACION_FITCH,
    MAX(h.EMIS_TASA)                AS EMIS_TASA,
    SUM(h.VALOR_NOMINAL)            AS VALOR_NOMINAL,
    SUM(h.VALOR_REAL)               AS VALOR_REAL,
    CASE WHEN SUM(h.VALOR_REAL) IS NULL OR SUM(h.VALOR_REAL)=0 THEN NULL
         ELSE SUM(NVL(h.PLAZO_REPORTO,0) * h.VALOR_REAL) / SUM(h.VALOR_REAL)
    END                             AS DURACION_DIAS,
    TRUNC(MAX(e.FECHA_VTO_EM)) - TRUNC(MAX(h.REGISTRO_CONTROL)) AS DIAS_X_V,
    MAX(TRUNC(h.REGISTRO_CONTROL)) AS FECHA_CORTE,
    MAX(vtr.TASA)                   AS TASA_BASE,
    MAX(vtr.TASA_REFERENCIA)        AS TASA_REF_NAME
FROM H_CORTE h
LEFT JOIN SIAPII.V_M_EMISORA e ON e.ID_EMISORA = h.ID_EMISORA
LEFT JOIN VTR_REF vtr ON vtr.ID_TASA_REFERENCIA = e.ID_TASA_REFERENCIA
WHERE e.ID_TIPO_ACTIVO = 1
  AND h.ID_PRODUCTO NOT IN ({REPORTO_RV_CSV})
GROUP BY h.ID_PRODUCTO, e.ID_EMISORA
ORDER BY SUM(h.VALOR_REAL) DESC NULLS LAST, MAX(e.NOMBRE_EMISORA)
"""
    return run_sql(SQL_SNAPSHOT, params=params)

# ===== Ratings helpers + carry =====
VAL_TO_BUCKET = {
    1:"AAA",2:"AA+",3:"AA",4:"AA-",5:"A+",6:"A",7:"A-",
    8:"BBB+",9:"BBB",10:"BBB-",11:"BB+",12:"BB",13:"BB-",
    14:"B+",15:"B",16:"B-",17:"CCC+",18:"CCC",19:"CCC-",
    20:"CC+",21:"CC",22:"CC-",23:"C+",24:"C",25:"C-",26:"D"
}
RATING_RULES = [
    (r'^(MX)?AAA(\b|/|\()', 1),(r'^(AAA/)[1-7]$', 1),(r'^(A-?1\+|HR\+?1|HR\s*\+?1|F1\+|P-?1)\b', 1),
    (r'^(MX)?AA\+(\b|/|\()', 2),(r'^(MX)?AA(\b|/|\()', 3),(r'^(MX)?AA-(\b|/|\()', 4),
    (r'^(MX)?A\+(\b|/|\()', 5),(r'^(MX)?A(\b|/|\()', 6),(r'^(MX)?A-(\b|/|\()', 7),
    (r'^(MX)?BBB\+(\b|/|\()', 8),(r'^(MX)?BBB(\b|/|\()', 9),(r'^(MX)?BBB-(\b|/|\()', 10),
    (r'^(MX)?BB\+(\b|/|\()', 11),(r'^(MX)?BB(\b|/|\()', 12),(r'^(MX)?BB-(\b|/|\()', 13),
    (r'^(MX)?B\+(\b|/|\()', 14),(r'^(MX)?B(\b|/|\()', 15),(r'^(MX)?B-(\b|/|\()', 16),
    (r'^(MX)?CCC\+(\b|/|\()', 17),(r'^(MX)?CCC(\b|/|\()', 18),(r'^(MX)?CCC-(\b|/|\()', 19),
    (r'^(MX)?CC\+(\b|/|\()', 20),(r'^(MX)?CC(\b|/|\()', 21),(r'^(MX)?CC-(\b|/|\()', 22),
    (r'^(MX)?C\+(\b|/|\()', 23),(r'^(MX)?C(\b|/|\()', 24),(r'^(MX)?C-(\b|/|\()', 25),
    (r'^(MX)?D(\b|/|\()', 26),(r'^RD(\(MEX\))?$', 26),
    (r'^AAA\.?MX$', 1),(r'^AA\+\.?MX$', 2),(r'^AA\.?MX$', 3),(r'^AA-\.?MX$', 4),
    (r'^A\+\.?MX$', 5),(r'^A\.?MX$', 6),(r'^A-\.?MX$', 7),
    (r'^BBB\+\.?MX$', 8),(r'^BBB\.?MX$', 9),(r'^BBB-\.?MX$', 10),
    (r'^BB\+\.?MX$', 11),(r'^BB\.?MX$', 12),(r'^BB-\.?MX$', 13),
    (r'^B\+\.?MX$', 14),(r'^B\.?MX$', 15),(r'^B-\.?MX$', 16),
    (r'^CCC\+\.?MX$', 17),(r'^CCC\.?MX$', 18),(r'^CCC-\.?MX$', 19),
    (r'^Aaa$', 1),(r'^Aa1$', 2),(r'^Aa2$', 3),(r'^Aa3$', 4),
    (r'^A1$', 5),(r'^A2$', 6),(r'^A3$', 7),
    (r'^Baa1$', 8),(r'^Baa2$', 9),(r'^Baa3$', 10),
    (r'^Ba1$', 11),(r'^Ba2$', 12),(r'^Ba3$', 13),
    (r'^B1$', 14),(r'^B2$', 15),(r'^B3$', 16),
    (r'^Caa1$', 17),(r'^Caa2$', 18),(r'^Caa3$', 19),
    (r'^Ca$', 21),(r'^C$', 24),
    (r'^HR\+?1$', 1),(r'^HR1$', 1),(r'^HR2$', 2),(r'^HR3$', 9),(r'^HR4$', 17),(r'^HR5$', 26),
    (r'^F1\+$', 1),(r'^F1$', 2),(r'^F2$', 6),(r'^F3$', 9),
    (r'^P-?1$', 1),(r'^P-?2$', 3),(r'^P-?3$', 6),
]
def _norm(s: str) -> str:
    if s is None: return ""
    s = str(s).strip()
    if s == "" or s.lower() == "nan": return ""
    return s
def rating_to_value(s: str) -> float:
    s0 = _norm(s)
    if not s0: return np.nan
    s1 = s0.upper().replace('.', '').replace(' ', '')
    s1 = s1.replace('(G)', '').replace('(MEX)', '').replace('(MX)', '')
    s2 = s0.strip()
    for pat, val in RATING_RULES:
        if re.match(pat, s1) or re.match(pat, s2, flags=re.IGNORECASE):
            return float(val)
    return np.nan

def eq365(rate_dec, cap_series):
    base = 1.0 + (rate_dec / cap_series.replace(0, np.nan))
    base = pd.Series(base, index=cap_series.index).fillna(1.0)
    K = 360.0/365.0
    return (base.pow(cap_series / K) - 1.0) * K

def min_rating_from_row(row: pd.Series):
    fuentes = [
        ("S&P",     row.get("CALIFICACION_S_P", None)),
        ("MDYS",    row.get("CALIFICACION_MDYS", None)),
        ("HR",      row.get("CALIFICACION_HRRATING", None)),
        ("FITCH",   row.get("CALIFICACION_FITCH", None)),
        ("HOMO",    row.get("CALIFICACION_HOMOLOGADA", None)),
    ]
    mejor_val = np.nan; mejor_raw = ""; mejor_src = ""
    for src, raw in fuentes:
        val = rating_to_value(raw)
        if pd.isna(val): continue
        if pd.isna(mejor_val) or val < mejor_val:
            mejor_val = val; mejor_raw = str(raw) if raw is not None else ""; mejor_src = src
    return mejor_val, mejor_raw, mejor_src

def _parse_rate_any(x):
    if pd.isna(x): return np.nan
    s = str(x).strip().replace('%','').replace(' ','')
    if s.count(',') == 1 and s.count('.') == 0: s = s.replace(',', '.')
    s = re.sub(r'(?<=\d),(?=\d{3}\b)', '', s)
    try: return float(s)
    except: return np.nan

def _auto_to_decimal(series):
    vals = pd.to_numeric(series, errors='coerce')
    med = vals.dropna().median()
    return vals if (pd.notna(med) and 0 < med < 1) else vals * 0.01

@st.cache_data(ttl=900, show_spinner=True)
def map_productos() -> pd.DataFrame:
    return run_sql("""
        SELECT ID_PRODUCTO, COALESCE(DESCRIPCION,'SIN_DESCRIPCION') AS PRODUCTO
        FROM SIAPII.V_M_PRODUCTO
    """)

@st.cache_data(ttl=900, show_spinner=True)
def build_df_final(df_snap: pd.DataFrame, inflacion_anual: float) -> pd.DataFrame:
    if df_snap is None or df_snap.empty:
        return pd.DataFrame()
    df = df_snap.copy()
    rating_info = df.apply(min_rating_from_row, axis=1, result_type='expand')
    rating_info.columns = ['VALOR_RATING_MIN', 'RAW_RATING_MIN', 'SRC_RATING_MIN']
    df = pd.concat([df, rating_info], axis=1)
    ytm_dec   = _auto_to_decimal(df['EMIS_TASA'].apply(_parse_rate_any))
    tbase_dec = _auto_to_decimal(df.get('TASA_BASE', pd.Series([np.nan]*len(df))).apply(_parse_rate_any))
    f_vto = pd.to_datetime(df['FECHA_VTO_EM'], errors='coerce')
    f_corte = pd.to_datetime(df['FECHA_CORTE'], errors='coerce')
    dxv_bruto = (f_vto - f_corte).dt.days
    is_reporto = df['TIPO_PAPEL'].astype(str).str.contains('reporto', case=False, na=False) | \
                 df['TIPO_INSTRUMENTO'].astype(str).str.contains('reporto', case=False, na=False)
    is_cero = df['TIPO_INSTRUMENTO'].astype(str).str.contains('cero', case=False, na=False)
    dxv_mostrado = pd.Series(np.where(is_reporto, 1, dxv_bruto), index=df.index)
    plazo = pd.to_numeric(df['PLAZO_CUPON'], errors='coerce')
    dxv_sql = pd.to_numeric(df.get('DIAS_X_V', np.nan), errors='coerce')
    dxv_real = dxv_sql.where(dxv_sql.notna(), dxv_bruto)
    periodo_dias = pd.Series(np.where(is_reporto, 1,
                                      np.where(is_cero & pd.notna(dxv_real) & (dxv_real > 0), dxv_real, plazo)),
                             index=df.index).fillna(28).clip(lower=1)
    cap = 360.0 / periodo_dias
    infl = float(inflacion_anual)
    es_real = (df['TIPO_INSTRUMENTO'].astype(str).str.contains('tasa real', case=False, na=False)) & \
              (pd.to_numeric(df['ID_DIVISA_TV'], errors='coerce') == 8)
    es_revisable = df['TIPO_INSTRUMENTO'].astype(str).str.contains('revis', case=False, na=False)
    mask_nominal = ~(es_real | es_revisable)
    t_eq_nominal   = eq365(ytm_dec, cap)
    t_in_revisable = tbase_dec.fillna(0.0) + ytm_dec.fillna(0.0)
    t_eq_revisable = eq365(t_in_revisable, cap)
    t_eq_real      = eq365(ytm_dec, cap)
    K = 360.0/365.0
    t_nom_real     = ((1.0 + (t_eq_real / K)) * (1.0 + (infl / K)) - 1.0) * K
    t_carry = pd.Series(np.nan, index=df.index, dtype=float)
    t_carry[mask_nominal] = t_eq_nominal[mask_nominal]
    t_carry[es_revisable] = t_eq_revisable[es_revisable]
    t_carry[es_real]      = t_nom_real[es_real]
    val_real = pd.to_numeric(df['VALOR_REAL'], errors='coerce').fillna(0.0)
    peso = (val_real / val_real.sum()) if val_real.sum() > 0 else pd.Series(0.0, index=df.index)
    val_nom_raw = pd.to_numeric(df['VALOR_NOMINAL'], errors='coerce').fillna(0.0) * 100.0
    val_nom_raw = np.where(is_reporto, 0.0, val_nom_raw)
    carry_total_pp = float((t_carry * peso).sum() * 100.0)
    dxv_total_pond = float((dxv_mostrado.fillna(0.0) * peso).sum())
    duracion_dias  = pd.to_numeric(df.get('DURACION_DIAS', np.nan), errors='coerce')
    dur_portafolio = float((duracion_dias.fillna(0.0) * peso).sum()) if 'DURACION_DIAS' in df else None
    nombre = df['NOMBRE_EMISORA'].astype(str).fillna("")
    serie  = df.get('SERIE', pd.Series([""]*len(df))).astype(str).fillna("").replace("nan","")
    instrumento = nombre.str.strip().str.cat(serie.apply(lambda s: (" " + s.strip()) if s and s.strip() else ""), na_rep="")
    df_final = pd.DataFrame({
        'Tipo de Papel'       : df['TIPO_PAPEL'].astype(str),
        'Tipo de instrumento' : df['TIPO_INSTRUMENTO'].astype(str),
        'Instrumento'         : instrumento,
        'Fecha vto'           : f_vto.dt.date,
        'DxV'                 : dxv_mostrado,
        'Duración (días)'     : (pd.to_numeric(duracion_dias, errors='coerce').round(0).astype('Int64')
                                  if 'DURACION_DIAS' in df else pd.Series([pd.NA]*len(df))),
        'Tasa valuacion'      : [fmt_pct(x) for x in t_eq_nominal],
        'Carry (365 d)'       : [fmt_pct(x) for x in t_carry],
        'Valor Nominal'       : [f"{v:,.0f}" for v in val_nom_raw],
        'Monto'               : val_real.map(fmt_money2),
        '% Cartera'           : (peso * 100).map(lambda x: f"{x:.2f}%"),
        'Tasa ref'            : df.get('TASA_REF_NAME', pd.Series(['']*len(df))).astype(str),
        'Tasa base'           : df.get('TASA_BASE', pd.Series([np.nan]*len(df))),
        'Calificación'        : df['RAW_RATING_MIN'].fillna(df['CALIFICACION_HOMOLOGADA'].astype(str)),
        '_VALOR_RATING_MIN'   : df['VALOR_RATING_MIN'],
        '_ID_PRODUCTO'        : df['ID_PRODUCTO']
    })
    mp = map_productos()
    df_final = df_final.merge(mp, left_on="_ID_PRODUCTO", right_on="ID_PRODUCTO", how="left")
    df_final.drop(columns=["ID_PRODUCTO"], inplace=True, errors="ignore")
    df_final.rename(columns={"PRODUCTO": "Producto"}, inplace=True)
    ord_tp = {'Reporto':1,'Gubernamental':2,'CuasiGuber':3,'Banca Comercial':4,'Privado':5}
    is_rep2 = df_final['Tipo de Papel'].str.contains('reporto', case=False, na=False) | \
              df_final['Tipo de instrumento'].str.contains('reporto', case=False, na=False)
    df_final['__ord__'] = np.where(is_rep2, 1, df_final['Tipo de Papel'].map(ord_tp).fillna(98))
    df_final['__m__']   = money_to_float_series(df_final['Monto'])
    df_detail = (df_final
                 .sort_values(['__ord__','__m__'], ascending=[True, False])
                 .drop(columns=['__ord__','__m__'])
                 .reset_index(drop=True))
    mask_rep_det = df_detail['Tipo de Papel'].str.contains('reporto', case=False, na=False) | \
                   df_detail['Tipo de instrumento'].str.contains('reporto', case=False, na=False)
    df_detail.loc[mask_rep_det, 'Calificación'] = 'MXAAA'
    if len(df_detail):
        row_total = {
            'Producto':'','Tipo de Papel':'','Tipo de instrumento':'','Instrumento':'TOTAL','Fecha vto':'',
            'DxV':f"{dxv_total_pond:.0f}", 'Duración (días)':(f"{dur_portafolio:.0f}" if dur_portafolio is not None else ''),
            'Tasa valuacion':'', 'Carry (365 d)':f"{carry_total_pp:.2f}%",
            'Valor Nominal':'', 'Monto':f"${float(money_to_float_series(df_detail['Monto']).sum()):,.2f}",
            '% Cartera':"100.00%", 'Tasa ref':'', 'Tasa base':'', 'Calificación':'',
            '_VALOR_RATING_MIN':np.nan, '_ID_PRODUCTO':np.nan
        }
        df_detail = pd.concat([df_detail, pd.DataFrame([row_total])], ignore_index=True)
    return df_detail

# =========================
#  core_issuer y RV
# =========================
@st.cache_data(ttl=3600, show_spinner=True)
def core_issuer_map() -> pd.DataFrame:
    core = pg_run_sql("""
        SELECT issuer_name, ticker_symbol, sector, industry
        FROM core_issuer
        WHERE issuer_name IS NOT NULL
    """)
    if core.empty:
        return pd.DataFrame(columns=["issuer_name","Nombre Completo","sector","industry"])
    core = core.copy()
    core["issuer_name"] = core["issuer_name"].astype(str)
    core["ticker_symbol"] = core.get("ticker_symbol", pd.Series(index=core.index, dtype=object))
    core["sector"] = core.get("sector", pd.Series(index=core.index, dtype=object))
    core["industry"] = core.get("industry", pd.Series(index=core.index, dtype=object))
    def _mode_or_default(s, default_val):
        s = s.dropna()
        return s.value_counts().index[0] if len(s) else default_val
    agg = (core.groupby("issuer_name", dropna=False)
           .agg({
               "ticker_symbol": lambda s: _mode_or_default(s, None),
               "sector":        lambda s: _mode_or_default(s, "SIN SECTOR"),
               "industry":      lambda s: _mode_or_default(s, "SIN INDUSTRIA"),
           })
           .reset_index())
    agg["Nombre Completo"] = np.where(
        agg["ticker_symbol"].notna() & (agg["ticker_symbol"].astype(str).str.strip() != ""),
        agg["ticker_symbol"].astype(str),
        agg["issuer_name"].astype(str)
    )
    agg["Nombre Completo"] = agg["Nombre Completo"].str.split(",", n=1, expand=True)[0].str.strip()
    agg["sector"] = agg["sector"].fillna("SIN SECTOR")
    agg["industry"] = agg["industry"].fillna("SIN INDUSTRIA")
    return agg[["issuer_name","Nombre Completo","sector","industry"]]

@st.cache_data(ttl=900, show_spinner=True)
def rv_snapshot_por_producto(alias: str, f_ini: pd.Timestamp, f_fin_next: pd.Timestamp) -> pd.DataFrame:
    SQL = f"""
    WITH FECHA_C AS (
      SELECT MAX(TRUNC(h.REGISTRO_CONTROL)) AS FECHA_CORTE
      FROM SIAPII.V_HIS_POSICION_CLIENTE h
      WHERE TRUNC(h.REGISTRO_CONTROL) >= TO_DATE(:f_ini_dt,'YYYY-MM-DD')
        AND TRUNC(h.REGISTRO_CONTROL) <  TO_DATE(:f_fin_dt,'YYYY-MM-DD')
        AND EXISTS (SELECT 1 FROM SIAPII.V_M_CONTRATO_CDM c
                    WHERE c.ALIAS_CDM = :alias AND c.ID_CLIENTE = h.ID_CLIENTE)
    )
    SELECT
      h.ID_PRODUCTO,
      MAX(e.NOMBRE_EMISORA) AS NOMBRE_EMISORA,
      SUM(h.VALOR_REAL)     AS MONTO
    FROM SIAPII.V_HIS_POSICION_CLIENTE h
    JOIN FECHA_C fc ON TRUNC(h.REGISTRO_CONTROL) = fc.FECHA_CORTE
    JOIN SIAPII.V_M_CONTRATO_CDM c ON c.ID_CLIENTE = h.ID_CLIENTE AND c.ALIAS_CDM = :alias
    JOIN SIAPII.V_M_EMISORA e ON e.ID_EMISORA = h.ID_EMISORA
    WHERE (e.ID_TIPO_ACTIVO = 2 OR h.ID_PRODUCTO IN ({REPORTO_RV_CSV}))
    GROUP BY h.ID_PRODUCTO, e.ID_EMISORA
    HAVING SUM(h.VALOR_REAL) IS NOT NULL
    """
    return run_sql(SQL, {
        "alias": alias,
        "f_ini_dt": f_ini.strftime("%Y-%m-%d"),
        "f_fin_dt": f_fin_next.strftime("%Y-%m-%d"),
    })

# =========================
#  HISTÓRICO trimestral + duración
# =========================
@st.cache_data(ttl=3600, show_spinner=True)
def hist_trimestral_papel_instrumento(alias: str, id_tipo_activo: int):
    SQL = f"""
    WITH H AS (
      SELECT
        TRUNC(h.REGISTRO_CONTROL, 'Q') AS Q,
        CASE 
          WHEN h.ID_PRODUCTO IN ({REPORTO_RV_CSV}) THEN 2
          ELSE e.ID_TIPO_ACTIVO
        END AS ID_ACTIVO_LOGICO,
        e.TIPO_PAPEL,
        e.TIPO_INSTRUMENTO,
        SUM(h.VALOR_REAL) AS MONTO
      FROM SIAPII.V_HIS_POSICION_CLIENTE h
      JOIN SIAPII.V_M_EMISORA e ON e.ID_EMISORA = h.ID_EMISORA
      JOIN SIAPII.V_M_CONTRATO_CDM c ON c.ID_CLIENTE = h.ID_CLIENTE
      WHERE c.ALIAS_CDM = :alias
        AND h.REGISTRO_CONTROL >= TO_DATE('2020-01-01','YYYY-MM-DD')
      GROUP BY TRUNC(h.REGISTRO_CONTROL, 'Q'),
               CASE 
                 WHEN h.ID_PRODUCTO IN ({REPORTO_RV_CSV}) THEN 2
                 ELSE e.ID_TIPO_ACTIVO
               END,
               e.TIPO_PAPEL, e.TIPO_INSTRUMENTO
    ),
    FILT AS (
      SELECT Q, TIPO_PAPEL, TIPO_INSTRUMENTO, MONTO
      FROM H WHERE ID_ACTIVO_LOGICO = :id_act
    ),
    TOT AS ( SELECT Q, SUM(MONTO) AS TOT FROM FILT GROUP BY Q )
    SELECT
      TO_CHAR(f.Q,'YYYY') || '-Q' || TO_CHAR(f.Q,'Q') AS PERIODO,
      f.TIPO_PAPEL,
      f.TIPO_INSTRUMENTO,
      f.MONTO,
      t.TOT,
      CASE WHEN t.TOT=0 OR t.TOT IS NULL THEN 0 ELSE (f.MONTO/t.TOT)*100 END AS PCT
    FROM FILT f
    JOIN TOT  t ON t.Q = f.Q
    """
    df = run_sql(SQL, {"alias": alias, "id_act": id_tipo_activo})
    if df.empty:
        return (pd.DataFrame(columns=["PERIODO","TIPO_PAPEL","Pct"]),

                pd.DataFrame(columns=["PERIODO","TIPO_INSTRUMENTO","Pct"]))
    df = df.rename(columns={"PCT": "Pct"})
    df["Pct"] = pd.to_numeric(df["Pct"], errors="coerce").fillna(0.0)
    por_papel = df.groupby(["PERIODO","TIPO_PAPEL"], dropna=False)["Pct"].sum().reset_index()
    por_instr = df.groupby(["PERIODO","TIPO_INSTRUMENTO"], dropna=False)["Pct"].sum().reset_index()
    def _key(p):
        y, q = p.split("-Q")
        return (int(y), int(q))
    por_papel = por_papel.sort_values(by="PERIODO", key=lambda s: s.map(_key)).reset_index(drop=True)
    por_instr = por_instr.sort_values(by="PERIODO", key=lambda s: s.map(_key)).reset_index(drop=True)
    return por_papel, por_instr

@st.cache_data(ttl=1800, show_spinner=True)
def deuda_duracion_historico(alias: str, inflacion_anual: float, f_ref_fin: pd.Timestamp) -> pd.DataFrame:
    filas = []
    ref_period = f_ref_fin.to_period("M")
    for k in range(11, -1, -1):
        periodo = ref_period - k
        mes_end = periodo.to_timestamp("M")
        mes_ini = mes_end.replace(day=1)
        mes_end_next = mes_end + pd.Timedelta(days=1)
        df_snap = query_snapshot_deuda(alias, mes_ini, mes_end_next)
        df_det = build_df_final(df_snap, inflacion_anual)
        if df_det is None or df_det.empty:
            continue
        total_row = df_det[df_det["Instrumento"].astype(str).str.upper() == "TOTAL"].tail(1)
        if total_row.empty:
            continue
        dur = pd.to_numeric(total_row["Duración (días)"], errors="coerce").iloc[0]
        if pd.isna(dur):
            continue
        filas.append({"MES": mes_end, "DURACION_DIAS": float(dur)})
    if not filas:
        return pd.DataFrame(columns=["MES", "DURACION_DIAS"])
    return pd.DataFrame(filas).sort_values("MES").reset_index(drop=True)

# =========================
#  CONSULTAS BASE / PARAMS
# =========================
with st.spinner("Consultando Oracle / Postgres y construyendo vistas…"):
    QUERY_BASE_AA = build_query_base_unfiltered(ALIAS_CDM, FECHA_ESTADISTICA)
    base = run_sql(QUERY_BASE_AA, params={"alias": ALIAS_CDM, "fecha": FECHA_ESTADISTICA})
    if not base.empty:
        base["MONTO"] = pd.to_numeric(base["MONTO"], errors="coerce").fillna(0.0)
        by_activo = base.groupby("ACTIVO", dropna=False)["MONTO"].sum().sort_values(ascending=False)
        by_producto = base.groupby(["PRODUCTO","ACTIVO"], dropna=False)["MONTO"].sum().reset_index()
        df_aa_activo = (by_activo.reset_index()
                        .rename(columns={"MONTO":"Monto","ACTIVO":"Categoria"})
                        .assign(Porcentaje=lambda d: (d["Monto"]/d["Monto"].sum()*100).round(2))
                        .sort_values("Monto", ascending=False).reset_index(drop=True))
        df_aa_producto = (by_producto
                          .assign(Porcentaje=lambda d: (d["MONTO"]/d["MONTO"].sum()*100).round(2))
                          .rename(columns={"MONTO":"Monto"})
                          .sort_values("Monto", ascending=False)
                          .reset_index(drop=True))
    else:
        df_aa_activo = pd.DataFrame(columns=["Categoria","Monto","Porcentaje"])
        df_aa_producto = pd.DataFrame(columns=["PRODUCTO","ACTIVO","Monto","Porcentaje"])

cto_m_anual, cto_ytd_anual, df_rend_prod = rend_bruto_contrato_y_producto(ALIAS_CDM, y, m)
df_hist_rend      = rend_bruto_contrato_hist_12m(ALIAS_CDM, y, m)
df_hist_rend_prod = rend_bruto_producto_hist_12m(ALIAS_CDM, y, m)
with st.spinner("Calculando Deuda…"):
    df_snap_deuda = query_snapshot_deuda(ALIAS_CDM, F_DIA_INI, F_DIA_FIN_NEXT)
    df_final_deuda = build_df_final(df_snap_deuda, INFLACION_ANUAL)

rv_df_raw = rv_snapshot_por_producto(ALIAS_CDM, F_DIA_INI, F_DIA_FIN_NEXT)
core_map_df = core_issuer_map()
rv_enriq_base = pd.DataFrame()
if not rv_df_raw.empty:
    rv_enriq_base = rv_df_raw.merge(core_map_df, left_on="NOMBRE_EMISORA", right_on="issuer_name", how="left")
    mp_rv = map_productos()
    rv_enriq_base = rv_enriq_base.merge(mp_rv[["ID_PRODUCTO","PRODUCTO"]], on="ID_PRODUCTO", how="left")
    rv_enriq_base.rename(columns={"PRODUCTO": "Producto"}, inplace=True)
    rv_enriq_base["industry"] = rv_enriq_base["industry"].fillna("SIN INDUSTRIA")
    rv_enriq_base["sector"] = rv_enriq_base["sector"].fillna("SIN SECTOR")
    rv_enriq_base["Nombre Completo"] = rv_enriq_base.get("Nombre Completo", rv_enriq_base["NOMBRE_EMISORA"].astype(str))
    rv_enriq_base["Nombre Completo"] = rv_enriq_base["Nombre Completo"].astype(str).str.split(",", n=1, expand=True)[0].str.strip()

hist_deuda_papel, hist_deuda_instr = hist_trimestral_papel_instrumento(ALIAS_CDM, 1)
hist_rv_papel,    hist_rv_instr    = hist_trimestral_papel_instrumento(ALIAS_CDM, 2)
hist_dur = deuda_duracion_historico(ALIAS_CDM, INFLACION_ANUAL, F_DIA_FIN)

# =========================
#  TÍTULO
# =========================
st.markdown("<br>", unsafe_allow_html=True)
NOMBRE_CLIENTE = get_nombre_cliente(ALIAS_CDM)

if not print_mode:
    # Vista normal
    st.markdown("<br>", unsafe_allow_html=True)
    st.title(f"REPORTE {NOMBRE_CLIENTE}")
    st.markdown(
        f'<span class="chip" style="color:#0f172a;">FECHA: {FECHA_ESTADISTICA}</span>',
        unsafe_allow_html=True
    )
    st.markdown("<br>", unsafe_allow_html=True)
else:
    # Vista de impresión: sin saltos extra
    st.title(f"REPORTE {NOMBRE_CLIENTE}")
    st.markdown(
        f'<span class="chip" style="color:#0f172a;">FECHA: {FECHA_ESTADISTICA}</span>',
        unsafe_allow_html=True
    )
st.markdown("<br>", unsafe_allow_html=True)

# =========================
#  VISUALES BÁSICOS
# =========================
def donut_figure(labels, values, title: str, height=400, top_n: int | None = None, kind: str = "money") -> go.Figure:
    vals = pd.to_numeric(pd.Series(values), errors='coerce').fillna(0.0).values
    labs = pd.Series(labels).astype(str).values
    total = float(np.nansum(vals))
    if total <= 0:
        labs, vals, total = np.array(["Sin datos"]), np.array([1.0]), 0.0
    else:
        order = np.argsort(-vals)
        labs, vals = labs[order], vals[order]
        if top_n is not None and top_n > 0:
            labs, vals = labs[:top_n], vals[:top_n]
    if kind == "money":
        textinfo = "percent"
        texttemplate = "%{percent:.1%}"
        hovertemplate = "%{label}<br>$%{value:,.0f} (%{percent:.1%})<extra></extra>"
        annot_text = f"Total<br>${total:,.0f}"
    else:
        textinfo = "label+text"
        texttemplate = "%{value:.1f}%"
        hovertemplate = "%{label}<br>%{value:.2f}%<extra></extra>"
        annot_text = f"Total<br>{total:.1f}%"
    fig = go.Figure(data=[go.Pie(
        labels=labs, values=vals, hole=.55, sort=False,
        textinfo=textinfo, texttemplate=texttemplate,
        hovertemplate=hovertemplate
    )])
    fig.update_layout(
        title=title, showlegend=True, legend=LEGEND_RIGHT,
        margin=dict(l=10, r=220, t=42, b=6),
        paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
        font=dict(color='#0f172a'), height=height,
        annotations=[dict(text=annot_text, x=0.5, y=0.5, font=dict(size=12), showarrow=False)]
    )
    return fig

def area100_from_pivot(pvt: pd.DataFrame, title: str, height=BARH_H, tickvals=None):
    if pvt.empty:
        fig = go.Figure()
        fig.update_layout(title=title, height=height)
        return fig
    ord_cols = pvt.mean(axis=0).sort_values(ascending=False).index.tolist()
    pvt = pvt[ord_cols]
    fig = go.Figure()
    for col in pvt.columns:
        fig.add_trace(go.Scatter(
            x=pvt.index, y=pvt[col], mode="lines", stackgroup="one", groupnorm="percent",
            name=str(col), hovertemplate="%{x}<br>%{y:.2f}%<extra></extra>"
        ))
    xaxis_args = dict(title="Periodo", tickangle=TICKANGLE)
    if tickvals is not None:
        xaxis_args["tickmode"] = "array"
        xaxis_args["tickvals"] = tickvals
    fig.update_layout(
        title=title,
        yaxis=dict(title="% cartera", range=[0,100], ticksuffix="%"),
        xaxis=xaxis_args,
        legend=LEGEND_RIGHT,
        paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=220, t=42, b=6),
        height=height
    )
    return fig

# =========================
#  Helper rendimientos por producto (gráfica)
# =========================
def plot_rend_producto_series(df_hist_prod: pd.DataFrame, producto: str, modo: str, titulo_prefix: str):
    dfp = df_hist_prod[df_hist_prod["PRODUCTO"] == producto].copy()
    if dfp.empty:
        st.info("Sin rendimientos disponibles para este producto.")
        return
    dfp = dfp.sort_values(["ANIO","MES"])
    fechas = pd.to_datetime(dict(year=dfp["ANIO"], month=dfp["MES"], day=1), errors="coerce")
    dfp["LABEL"] = fechas.dt.strftime("%b-%y")
    if modo == "Anualizado":
        col_m = "TASA_M_ANUAL"
        col_a = "TASA_ACUM_ANUAL"
    else:
        col_m = "TASA_M_EFEC"
        col_a = "TASA_ACUM_EFEC"
    m_vals = (dfp[col_m] * 100.0).round(2)
    a_vals = (dfp[col_a] * 100.0).round(2)
    x_labels = dfp["LABEL"].tolist()
    m_vals_list = m_vals.tolist()
    a_vals_list = a_vals.tolist()
    sel = dfp[(dfp["ANIO"] == y) & (dfp["MES"] == m)]
    ytd_val = np.nan
    if not sel.empty and pd.notna(sel[col_a].iloc[0]):
        ytd_val = float(sel[col_a].iloc[0] * 100.0)
    x_labels_ext = x_labels + [f"Año {y}"]
    m_vals_ext = m_vals_list + [np.nan]
    a_vals_ext = a_vals_list + [ytd_val]
    text_m = [f"{v:.2f}%" if isinstance(v, (int,float)) and not np.isnan(v) else "" for v in m_vals_ext]
    text_a = [f"{v:.2f}%" if isinstance(v, (int,float)) and not np.isnan(v) else "" for v in a_vals_ext]
    fig = go.Figure()
    fig.add_trace(go.Bar(
        x=x_labels_ext,
        y=m_vals_ext,
        name="Mensual",
        hovertemplate="%{x}<br>Mensual: %{y:.2f}%<extra></extra>",
        text=text_m,
        textposition="outside"
    ))
    fig.add_trace(go.Bar(
        x=x_labels_ext,
        y=a_vals_ext,
        name="Acumulado",
        hovertemplate="%{x}<br>Acumulado: %{y:.2f}%<extra></extra>",
        text=text_a,
        textposition="outside"
    ))
    fig.update_layout(
        barmode="group",
        title=f"{titulo_prefix} — {producto}",
        yaxis=dict(title="Rendimiento (%)"),
        xaxis=dict(title="Mes", tickangle=0),
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1.0),
        margin=dict(l=10, r=10, t=60, b=40),
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        height=BARH_H
    )
    st.plotly_chart(fig, use_container_width=True, config={"displayModeBar": False})

# =========================
#  RENDER SECCIONES
# =========================
def render_resumen():
    # KPIs
    total_port = float(df_aa_activo["Monto"].sum()) if len(df_aa_activo) else 0.0
    n_productos = int(df_aa_producto["PRODUCTO"].nunique()) if len(df_aa_producto) else 0
    n_contratos = get_num_contratos(ALIAS_CDM)

    top_prod_row = (
        df_aa_producto.sort_values("Monto", ascending=False).head(1)
        if len(df_aa_producto) else pd.DataFrame()
    )
    top_prod_nom = str(top_prod_row["PRODUCTO"].iloc[0]) if not top_prod_row.empty else "—"
    top_prod_pct = float(top_prod_row["Porcentaje"].iloc[0]) if not top_prod_row.empty else 0.0
    top_prod_mnt = float(top_prod_row["Monto"].iloc[0]) if not top_prod_row.empty else 0.0

    # Rendimiento contrato (KPIs usan anualizados)
    kpi_rend_mes = "—"
    kpi_rend_ytd = "—"
    if df_hist_rend is not None and not df_hist_rend.empty:
        sel = df_hist_rend[(df_hist_rend["ANIO"] == y) & (df_hist_rend["MES"] == m)]
        if not sel.empty:
            row = sel.iloc[0]
            v_m = row["TASA_M_ANUAL"]
            v_y = row["TASA_ACUM_ANUAL"]
            if pd.notna(v_m):
                kpi_rend_mes = f"{v_m * 100:.2f}%"
            if pd.notna(v_y):
                kpi_rend_ytd = f"{v_y * 100:.2f}%"

    resumen_vals = {
        "Total Portafolio": f"${total_port:,.2f}",
        "# Contratos": f"{n_contratos:,}",
        "No. Estrategias": f"{n_productos:,}",
        "Top Estrategia": top_prod_nom,
        "Top %": f"{top_prod_pct:.2f}%",
        "Top Monto": f"${top_prod_mnt:,.2f}",
        "Rend. mensual (anualizado)": kpi_rend_mes,
        "Rend. acum. año (anualizado)": kpi_rend_ytd,
    }

    st.markdown(
        '<div class="kpi-grid">' +
        "".join(
            f'<div class="kpi-card"><div class="kpi-label">{k}</div>'
            f'<div class="kpi-value">{v}</div></div>'
            for k, v in resumen_vals.items()
        ) +
        '</div>',
        unsafe_allow_html=True
    )
    st.markdown("<br>", unsafe_allow_html=True)

    # ======================
    # PRINCIPALES HOLDINGS
    # ======================
    c1, c2 = st.columns((1, 1))

    # RV por industria (montos)
    rv_series = pd.Series(dtype=float)
    if not rv_enriq_base.empty:
        rv_series = (
            rv_enriq_base.groupby("industry")["MONTO"].sum()
            .rename_axis("Categoria").astype(float)
        )

    # Deuda por tipo de instrumento (monto absoluto)
    deuda_series = pd.Series(dtype=float)
    if not df_final_deuda.empty:
        mask_det = df_final_deuda["Instrumento"].astype(str).str.upper() != "TOTAL"
        tmp = df_final_deuda.loc[mask_det].copy()
        tmp["Tipo de instrumento"] = tmp["Tipo de instrumento"].replace(
            {None: "Reporto Guber Excento", "none": "Reporto Guber Excento", "None": "Reporto Guber Excento"}
        )
        monto_num = money_to_float_series(tmp["Monto"])
        deuda_series = monto_num.groupby(tmp["Tipo de instrumento"]).sum()
        deuda_series.index = deuda_series.index.astype(str)

    combined = pd.concat([
        rv_series.rename(lambda x: f"RV · {x}"),
        deuda_series.rename(lambda x: f"DEUDA · {x}")
    ]).groupby(level=0).sum().sort_values(ascending=False)

    combined_top = combined.head(5)

    with c1:
        if total_port <= 0 or len(combined_top) == 0:
            st.info("Sin datos suficientes para los principales holdings del portafolio.")
        else:
            etiquetas = combined_top.index.tolist()
            montos = combined_top.values.astype(float)
            pct_sobre_total = (montos / total_port * 100.0)

            fig_hold = go.Figure()
            for lab, pct in zip(etiquetas, pct_sobre_total):
                fig_hold.add_trace(go.Bar(
                    x=["Portafolio"],
                    y=[pct],
                    name=lab,
                    text=[f"{pct:.2f}%"],
                    textposition="outside",
                    hovertemplate="%{x}<br>" + lab + ": %{y:.2f}%<extra></extra>",
                ))

            fig_hold.update_layout(
                barmode="stack",
                title="Principales holdings del portafolio (Top 5)",
                yaxis=dict(
                    title="% del portafolio",
                    ticksuffix="%",
                    range=[0, 100]
                ),
                xaxis=dict(title=""),
                legend=LEGEND_RIGHT,
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="rgba(0,0,0,0)",
                margin=dict(l=10, r=220, t=42, b=6),
                height=CHART_H
            )
            fig_hold.update_traces(textfont_size=9, cliponaxis=False)
            st.plotly_chart(fig_hold, use_container_width=True, config={"displayModeBar": False})

    with c2:
        if len(combined_top) == 0 or total_port <= 0:
            st.info("Sin datos para el detalle de holdings.")
        else:
            df_donut = combined_top.reset_index()
            df_donut.columns = ["Categoría", "Monto"]
            df_donut["% Portafolio"] = (df_donut["Monto"] / total_port * 100).round(2)
            df_donut["Monto"] = df_donut["Monto"].map(lambda x: f"${x:,.2f}")
            df_donut["% Portafolio"] = df_donut["% Portafolio"].map(lambda x: f"{x:.2f}%")
            st.markdown("**Detalle Top 5 holdings**")
            if print_mode:
                tiny_table_print(df_donut)
            else:
                st.dataframe(df_donut, hide_index=True, use_container_width=True)

    st.markdown("<br>", unsafe_allow_html=True)

    # ======================
    # Gráficas de rendimientos 12m (SEPARADAS: Mensual y Acumulado)
    # ======================
    st.markdown("### Rendimiento bruto del contrato")

    modo = st.radio(
        "Tipo de rendimiento bruto mostrado",
        ["Anualizado", "Efectivo"],
        horizontal=True,
        index=0,
        key="modo_rend_resumen"
    )

    if df_hist_rend is None or df_hist_rend.empty:
        st.caption("No hay información de rendimientos brutos para los últimos 12 meses.")
    else:
        dfh = df_hist_rend.sort_values(["ANIO", "MES"]).copy()
        fechas = pd.to_datetime(
            dict(year=dfh["ANIO"], month=dfh["MES"], day=1),
            errors="coerce"
        )
        dfh["LABEL"] = fechas.dt.strftime("%b-%y")

        if modo == "Anualizado":
            col_m = "TASA_M_ANUAL"
            col_a = "TASA_ACUM_ANUAL"
        else:
            col_m = "TASA_M_EFEC"
            col_a = "TASA_ACUM_EFEC"

        m_vals = (dfh[col_m] * 100.0).round(2)
        a_vals = (dfh[col_a] * 100.0).round(2)
        x_labels = dfh["LABEL"].tolist()

        # Gráfica 1: Mensual
        fig_m = go.Figure()
        fig_m.add_trace(go.Scatter(
            x=x_labels,
            y=m_vals,
            mode="lines+markers+text",
            name="Mensual",
            text=[f"{v:.2f}%" if not pd.isna(v) else "" for v in m_vals],
            textposition="top center",
            hovertemplate="%{x}<br>Mensual: %{y:.2f}%<extra></extra>",
        ))
        fig_m.update_layout(
            title="Rendimiento bruto mensual",
            yaxis=dict(title="Rendimiento (%)"),
            xaxis=dict(title="Mes", tickangle=0),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1.0
            ),
            margin=dict(l=10, r=10, t=60, b=40),
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            height=BARH_H,
        )
        st.plotly_chart(fig_m, use_container_width=True, config={"displayModeBar": False})

        # Gráfica 2: Acumulado
        fig_a = go.Figure()
        fig_a.add_trace(go.Scatter(
            x=x_labels,
            y=a_vals,
            mode="lines+markers+text",
            name="Acumulado",
            text=[f"{v:.2f}%" if not pd.isna(v) else "" for v in a_vals],
            textposition="top center",
            hovertemplate="%{x}<br>Acumulado: %{y:.2f}%<extra></extra>",
        ))
        fig_a.update_layout(
            title="Rendimiento bruto acumulado",
            yaxis=dict(title="Rendimiento (%)"),
            xaxis=dict(title="Mes", tickangle=0),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1.0
            ),
            margin=dict(l=10, r=10, t=60, b=40),
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            height=BARH_H,
        )
        st.plotly_chart(fig_a, use_container_width=True, config={"displayModeBar": False})

def render_allocation_general():
    st.subheader("Portafolio")
    if not len(df_aa_producto):
        st.info("Sin productos en el periodo seleccionado.")
        return
    serie_prod = df_aa_producto.groupby("PRODUCTO")["Monto"].sum().sort_values(ascending=False)
    total_monto = float(serie_prod.sum())
    c1, c2 = st.columns((1,1))
    with c1:
        st.plotly_chart(
            donut_figure(serie_prod.index.tolist(), serie_prod.values.tolist(),
                         "Distribución por estrategia"),
            use_container_width=True, config={"displayModeBar": False}
        )
    with c2:
        df_tab = serie_prod.reset_index()
        df_tab.columns = ["Estrategia","Monto"]
        df_tab["%"] = (df_tab["Monto"]/total_monto*100).round(2)
        df_tab["Monto"] = df_tab["Monto"].map(lambda x: f"${x:,.2f}")
        df_tab["%"] = df_tab["%"].map(lambda x: f"{x:.2f}%")
        st.markdown("**Detalle**")
        if print_mode:
            tiny_table_print(df_tab)
        else:
            st.dataframe(df_tab, hide_index=True, use_container_width=True)

def render_allocation_detalle():
    st.subheader("Distribución por estrategia")
    prod_deuda = df_aa_producto[df_aa_producto["ACTIVO"]=="Deuda"]["PRODUCTO"].dropna().unique().tolist()
    prod_rv    = df_aa_producto[df_aa_producto["ACTIVO"]=="Renta Variable"]["PRODUCTO"].dropna().unique().tolist()
    c1, c2 = st.columns(2)
    with c1:
        sel_prod_deuda = st.multiselect("Estrategia — Deuda", options=prod_deuda, default=prod_deuda[:min(6, len(prod_deuda))])
        det_d = df_aa_producto[(df_aa_producto["ACTIVO"]=="Deuda") & (df_aa_producto["PRODUCTO"].isin(sel_prod_deuda))].copy()
        if det_d.empty:
            st.info("Selecciona al menos un producto Deuda.")
        else:
            det_d = det_d.groupby("PRODUCTO")["Monto"].sum().reset_index().sort_values("Monto", ascending=False)
            st.plotly_chart(donut_figure(det_d["PRODUCTO"], det_d["Monto"], "Deuda — Estrategias seleccionadas"),
                            use_container_width=True, config={"displayModeBar": False})
            vista = det_d.copy()
            vista["%"] = (vista["Monto"]/vista["Monto"].sum()*100).round(2)
            vista["Monto"] = vista["Monto"].map(lambda x: f"${x:,.2f}")
            vista["%"] = vista["%"].map(lambda x: f"{x:.2f}%")
            vista = vista.rename(columns={"PRODUCTO":"Producto"})
            if print_mode:
                tiny_table_print(vista)
            else:
                st.dataframe(vista, hide_index=True, use_container_width=True)
    with c2:
        sel_prod_rv = st.multiselect("Estrategia — Renta Variable", options=prod_rv, default=prod_rv[:min(6, len(prod_rv))])
        det_r = df_aa_producto[(df_aa_producto["ACTIVO"]=="Renta Variable") & (df_aa_producto["PRODUCTO"].isin(sel_prod_rv))].copy()
        if det_r.empty:
            st.info("Selecciona al menos un producto RV.")
        else:
            det_r = det_r.groupby("PRODUCTO")["Monto"].sum().reset_index().sort_values("Monto", ascending=False)
            st.plotly_chart(donut_figure(det_r["PRODUCTO"], det_r["Monto"], "Capitales — Estrategias seleccionadas"),
                            use_container_width=True, config={"displayModeBar": False})
            vista = det_r.copy()
            vista["%"] = (vista["Monto"]/vista["Monto"].sum()*100).round(2)
            vista["Monto"] = vista["Monto"].map(lambda x: f"${x:,.2f}")
            vista["%"] = vista["%"].map(lambda x: f"{x:.2f}%")
            vista = vista.rename(columns={"PRODUCTO":"Producto"})
            if print_mode:
                tiny_table_print(vista)
            else:
                st.dataframe(vista, hide_index=True, use_container_width=True)


def render_allocation_historico():
    st.subheader("Comportamiento de activos y estrategias")
    aa_activo, aa_producto = aa_hist_ultimo_5_anios(ALIAS_CDM)
    c1, c2 = st.columns((1,1))
    with c1:
        if aa_activo.empty:
            st.info("Sin histórico por tipo de activo.")
        else:
            p = aa_activo.copy()
            p["AX"] = p["ANIO"].astype(str)
            pivot_pp = p.pivot_table(index="AX", columns="ACTIVO", values="Pct", aggfunc="sum").fillna(0)
            tickvals = pivot_pp.index.tolist()
            st.plotly_chart(area100_from_pivot(pivot_pp, "Activos", tickvals=tickvals),
                            use_container_width=True, config={"displayModeBar": False})
    with c2:
        if aa_producto.empty:
            st.info("Sin histórico por producto.")
        else:
            topN = 10
            top_cols = (aa_producto.groupby("PRODUCTO")["Pct"].mean()
                        .sort_values(ascending=False).head(topN).index.tolist())
            p2 = aa_producto[aa_producto["PRODUCTO"].isin(top_cols)].copy()
            p2["AX"] = p2["ANIO"].astype(str)
            pivot_p2 = p2.pivot_table(index="AX", columns="PRODUCTO", values="Pct", aggfunc="sum").fillna(0)
            tickvals2 = pivot_p2.index.tolist()
            st.plotly_chart(area100_from_pivot(pivot_p2, "Productos", tickvals=tickvals2),
                            use_container_width=True, config={"displayModeBar": False})

def render_deuda_composicion(df_final):
    st.subheader("Composición de activos deuda")
    if df_final.empty:
        st.info("Sin instrumentos de Deuda en el corte actual.")
        return
    mask_det = df_final['Instrumento'].astype(str).str.upper() != 'TOTAL'
    df_det = df_final.loc[mask_det].copy()
    df_det['Tipo de instrumento'] = df_det['Tipo de instrumento'].replace(
        {None: 'Reporto Guber Excento', 'none': 'Reporto Guber Excento', 'None': 'Reporto Guber Excento'}
    )
    pct_num = pd.to_numeric(df_det['% Cartera'].str.replace('%','', regex=False), errors='coerce').fillna(0.0)
    serie_tp = pct_num.groupby(df_det['Tipo de Papel']).sum().sort_values(ascending=False)
    serie_ti = pct_num.groupby(df_det['Tipo de instrumento']).sum().sort_values(ascending=False)
    c1, c2 = st.columns((1,1))
    with c1:
        st.plotly_chart(
            donut_figure(
                serie_tp.index.tolist(),
                serie_tp.values.tolist(),
                "Por Tipo de Papel",
                kind="pct"
            ),
            use_container_width=True, config={"displayModeBar": False}
        )
    with c2:
        st.plotly_chart(
            donut_figure(
                serie_ti.index.tolist(),
                serie_ti.values.tolist(),
                "Por Tipo de Instrumento",
                kind="pct"
            ),
            use_container_width=True, config={"displayModeBar": False}
        )

def render_deuda_riesgo(df_final):
    st.subheader("Calificación")
    if df_final.empty:
        st.info("Sin instrumentos de Deuda en el corte actual.")
        return
    mask_det = df_final['Instrumento'].astype(str).str.upper() != 'TOTAL'
    df_det = df_final.loc[mask_det].copy()
    pct_num = pd.to_numeric(df_det['% Cartera'].str.replace('%','', regex=False), errors='coerce').fillna(0.0)
    vals = pd.to_numeric(df_det.get('_VALOR_RATING_MIN', np.nan), errors='coerce')
    is_rep = df_det['Tipo de Papel'].str.contains('reporto', case=False, na=False) | \
             df_det['Tipo de instrumento'].str.contains('reporto', case=False, na=False)
    vals.loc[is_rep] = 1.0
    escala = vals.map(lambda v: VAL_TO_BUCKET.get(int(v), "NR") if not pd.isna(v) else "NR")
    tabla = (pd.DataFrame({'Escala': escala, 'Pct': pct_num})
             .groupby('Escala', dropna=False)['Pct'].sum().reset_index()
             .sort_values('Pct', ascending=False))
    tabla["% Cartera"] = tabla["Pct"].map(lambda x: f"{x:.2f}%")
    tabla = tabla[["Escala","% Cartera"]].reset_index(drop=True)
    def color_row(row):
        e = str(row["Escala"])
        if e in ("AAA","AA+","AA","AA-","A+","A","A-"):
            c="#dcfce7"
        elif e in ("BBB+","BBB","BBB-"):
            c="#fef9c3"
        elif e in ("NR",):
            c="#e2e8f0"
        else:
            c="#fee2e2"
        return [f"background-color: {c}"]*len(row)
    styled = tabla.style.apply(color_row, axis=1)
    html = styled.to_html(index=False, border=0)
    st.markdown(f'<div class="table-print pb-after">{html}</div>', unsafe_allow_html=True)

    if hist_dur is not None and not hist_dur.empty:
        hd = hist_dur.copy()
        text_vals = [f"{v:.0f}" for v in hd["DURACION_DIAS"]]
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=hd["MES"], y=hd["DURACION_DIAS"],
            mode="lines+markers+text",
            name="Duración (días)",
            text=text_vals,
            textposition="top center",
            hovertemplate="%{x|%Y-%m}: %{y:.0f} días<extra></extra>"
        ))
        fig.update_layout(
            title="Duración - últimos 12 meses",
            yaxis=dict(title="Días"),
            xaxis=dict(title="Mes", tickangle=TICKANGLE),
            legend=LEGEND_RIGHT,
            paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
            margin=dict(l=10, r=220, t=42, b=6), height=BARH_H
        )
        st.plotly_chart(fig, use_container_width=True, config={"displayModeBar": False})
    else:
        st.caption("No hay histórico de duración disponible.")

def render_deuda_historico_trimestral():
    st.subheader("Comportamiento del tipo de papel e instrumento")
    c1, c2 = st.columns(2)
    with c1:
        if hist_deuda_papel.empty:
            st.info("Sin histórico por Tipo de Papel.")
        else:
            p = hist_deuda_papel.copy()
            pvt = p.pivot_table(index="PERIODO", columns="TIPO_PAPEL", values="Pct", aggfunc="sum").fillna(0)
            idx = list(pvt.index)
            tickvals = idx[::2] if len(idx) > 2 else idx
            fig = area100_from_pivot(pvt, "Tipo de Papel", tickvals=tickvals)
            st.plotly_chart(fig, use_container_width=True, config={"displayModeBar": False})
    with c2:
        if hist_deuda_instr.empty:
            st.info("Sin histórico por Tipo de Instrumento.")
        else:
            p2 = hist_deuda_instr.copy()
            pvt2 = p2.pivot_table(index="PERIODO", columns="TIPO_INSTRUMENTO", values="Pct", aggfunc="sum").fillna(0)
            idx2 = list(pvt2.index)
            tickvals2 = idx2[::2] if len(idx2) > 2 else idx2
            fig2 = area100_from_pivot(pvt2, "Tipo de Instrumento", tickvals=tickvals2)
            st.plotly_chart(fig2, use_container_width=True, config={"displayModeBar": False})

def render_deuda_tabla(df_final):
    st.subheader("Portafolio")
    if df_final.empty:
        st.info("Sin instrumentos de Deuda en el corte actual.")
        return

    mask_det = df_final['Instrumento'].astype(str).str.upper() != 'TOTAL'
    df_det = df_final.loc[mask_det].copy()

    df_det['Tipo de instrumento'] = df_det['Tipo de instrumento'].replace(
        {None: 'Reporto Guber Excento', 'none': 'Reporto Guber Excento', 'None': 'Reporto Guber Excento'}
    )

    productos = df_det["Producto"].fillna("SIN_DESCRIPCION").astype(str).unique().tolist()
    productos = sorted(productos, key=lambda x: x.upper())

    cols_order = [
        'Producto','Instrumento','Tipo de Papel','Tipo de instrumento','Calificación',
        'Fecha vto','DxV','Duración (días)','Tasa valuacion','Carry (365 d)',
        'Valor Nominal','Monto','% Cartera','Tasa ref','Tasa base'
    ]

    for prod in productos:
        sub = df_det[df_det["Producto"].fillna("SIN_DESCRIPCION").astype(str) == prod].copy()
        if sub.empty:
            continue

        sub["__m__"] = money_to_float_series(sub["Monto"])
        sub = sub.sort_values("__m__", ascending=False).drop(columns="__m__")

        cols_to_drop = ["_VALOR_RATING_MIN", "_ID_PRODUCTO", "Producto"]
        display_sub = sub.drop(columns=cols_to_drop, errors="ignore")

        cols_final = [c for c in cols_order if c in display_sub.columns] + \
                     [c for c in display_sub.columns if c not in cols_order]

        with st.expander(f"Producto: {prod}  —  instrumentos: {len(display_sub)}", expanded=False):
            st.markdown('<div class="deuda-detail-table">', unsafe_allow_html=True)
            if print_mode:
                tiny_table_print(display_sub[cols_final])
            else:
                altura = min(900, 60 + 22 * len(display_sub))
                st.dataframe(
                    display_sub[cols_final],
                    hide_index=True,
                    use_container_width=True,
                    height=altura
                )
            st.markdown('</div>', unsafe_allow_html=True)
            st.markdown("<br><em>Carry calculado a 365 días</em>", unsafe_allow_html=True)


def render_deuda_por_producto_comp(df_final):
    st.subheader("Composición por estrategia de deuda")
    if df_final.empty:
        st.info("Sin instrumentos de Deuda en el corte actual.")
        return
    mask_det = df_final['Instrumento'].astype(str).str.upper() != 'TOTAL'
    df_det = df_final.loc[mask_det].copy()
    df_det['Tipo de instrumento'] = df_det['Tipo de instrumento'].replace(
        {None: 'Reporto Guber Excento', 'none': 'Reporto Guber Excento', 'None': 'Reporto Guber Excento'}
    )
    productos = sorted(df_det["Producto"].fillna("SIN_DESCRIPCION").astype(str).unique().tolist())
    sel = st.multiselect("Selecciona estrategia(s) Deuda", options=productos, default=productos[:1])
    if not sel:
        st.info("Selecciona al menos un producto.")
        return
    for prod in sel:
        sub = df_det[df_det["Producto"].fillna("SIN_DESCRIPCION").astype(str) == prod].copy()
        if sub.empty:
            continue
        sub["MontoNum"] = money_to_float_series(sub["Monto"])
        serie_tp = sub.groupby("Tipo de Papel")["MontoNum"].sum().sort_values(ascending=False)
        serie_ti = sub.groupby("Tipo de instrumento")["MontoNum"].sum().sort_values(ascending=False)
        st.markdown(f"**Estrategia: {prod}**")
        c1, c2 = st.columns(2)
        with c1:
            st.plotly_chart(
                donut_figure(serie_tp.index.tolist(), serie_tp.values.tolist(),
                             f"{prod} — Tipo de Papel", kind="money"),
                use_container_width=True, config={"displayModeBar": False}
            )
        with c2:
            st.plotly_chart(
                donut_figure(serie_ti.index.tolist(), serie_ti.values.tolist(),
                             f"{prod} — Tipo de Instrumento", kind="money"),
                use_container_width=True, config={"displayModeBar": False}
            )

def render_deuda_rendimientos_por_producto():
    st.subheader("Rendimientos por estrategia de deuda")
    if df_hist_rend_prod is None or df_hist_rend_prod.empty:
        st.info("Sin rendimientos por producto disponibles.")
        return
    prod_act = df_aa_producto[["PRODUCTO","ACTIVO"]].drop_duplicates()
    df = df_hist_rend_prod.merge(prod_act, left_on="PRODUCTO", right_on="PRODUCTO", how="left")
    df = df[df["ACTIVO"] == "Deuda"]
    if df.empty:
        st.info("No hay productos de deuda con rendimientos.")
        return
    productos = sorted(df["PRODUCTO"].unique().tolist())
    prod_sel = st.selectbox("Estrategia Deuda", options=productos, index=0)
    modo = st.radio("Tipo de rendimiento", ["Anualizado","Efectivo"], horizontal=True, key="rend_deuda_prod")
    plot_rend_producto_series(df, prod_sel, modo, "Rendimientos brutos")

def render_rv_resumen():
    st.subheader("Distribución")
    if rv_enriq_base.empty:
        st.info("No hay RV en el corte actual.")
        return
    c1, c2 = st.columns((1,1))
    with c1:
        sec = rv_enriq_base.groupby("sector")["MONTO"].sum().reset_index().sort_values("MONTO", ascending=False)
        st.plotly_chart(donut_figure(sec["sector"], sec["MONTO"], "Distribución por Sector"),
                        use_container_width=True, config={"displayModeBar": False})
        sec_tab = sec.copy()
        sec_tab["%"] = (sec_tab["MONTO"]/sec_tab["MONTO"].sum()*100).round(2)
        sec_tab["MONTO"] = sec_tab["MONTO"].map(lambda x: f"${x:,.2f}")
        sec_tab["%"] = sec_tab["%"].map(lambda x: f"{x:.2f}%")
        sec_tab = sec_tab.rename(columns={"sector":"Sector","MONTO":"Monto"})
        st.markdown("**Detalle Sector**")
        if print_mode:
            tiny_table_print(sec_tab)
        else:
            st.dataframe(sec_tab, hide_index=True, use_container_width=True)
    with c2:
        ind = rv_enriq_base.groupby("industry")["MONTO"].sum().reset_index().sort_values("MONTO", ascending=False)
        st.plotly_chart(donut_figure(ind["industry"], ind["MONTO"], "Distribución por Industria"),
                        use_container_width=True, config={"displayModeBar": False})
        ind_tab = ind.copy()
        ind_tab["%"] = (ind_tab["MONTO"]/ind_tab["MONTO"].sum()*100).round(2)
        ind_tab["MONTO"] = ind_tab["MONTO"].map(lambda x: f"${x:,.2f}")
        ind_tab["%"] = ind_tab["%"].map(lambda x: f"{x:.2f}%")
        ind_tab = ind_tab.rename(columns={"industry":"Industria","MONTO":"Monto"})
        st.markdown("**Detalle Industria**")
        if print_mode:
            tiny_table_print(ind_tab)
        else:
            st.dataframe(ind_tab, hide_index=True, use_container_width=True)
    
    st.markdown("<br><em>Carry calculado a 365 días</em>", unsafe_allow_html=True)


def render_rv_por_producto():
    st.subheader("Participación de industria y sector por estrategia")
    if rv_enriq_base.empty:
        st.info("No hay RV en el corte actual.")
        return
    productos = sorted(rv_enriq_base["Producto"].fillna("SIN_DESCRIPCION").astype(str).unique().tolist())
    sel = st.multiselect("Selecciona estrategia(s) RV", options=productos, default=productos[:1])
    if not sel:
        st.info("Selecciona al menos un producto.")
        return
    for prod in sel:
        sub = rv_enriq_base[rv_enriq_base["Producto"].fillna("SIN_DESCRIPCION").astype(str) == prod]
        if sub.empty:
            continue
        c1, c2 = st.columns(2)
        with c1:
            sub_s = sub.groupby("sector")["MONTO"].sum().reset_index().sort_values("MONTO", ascending=False)
            st.plotly_chart(
                donut_figure(sub_s["sector"], sub_s["MONTO"], f"Estrategia {prod} — Sector"),
                use_container_width=True, config={"displayModeBar": False}
            )
        with c2:
            sub_i = sub.groupby("industry")["MONTO"].sum().reset_index().sort_values("MONTO", ascending=False)
            st.plotly_chart(
                donut_figure(sub_i["industry"], sub_i["MONTO"], f"Estrategia {prod} — Industria"),
                use_container_width=True, config={"displayModeBar": False}
            )
        view = (sub.groupby(["NOMBRE_EMISORA","Nombre Completo","industry","sector"])["MONTO"].sum()
                  .reset_index().sort_values("MONTO", ascending=False))
        view["MONTO"] = view["MONTO"].map(lambda x: f"${x:,.2f}")
        view = view.rename(columns={
            "NOMBRE_EMISORA":"Emisora",
            "Nombre Completo":"Nombre completo",
            "industry":"Industria",
            "sector":"Sector",
            "MONTO":"Monto"
        })
        if print_mode:
            tiny_table_print(view)
        else:
            st.dataframe(view, hide_index=True, use_container_width=True)

def render_rv_evolucion():
    st.subheader("Comportamiento en el tiempo de principales sectores e industrias")
    rv12 = run_sql(f"""
        WITH H AS (
          SELECT
            TRUNC(h.REGISTRO_CONTROL,'MM') AS MES,
            e.NOMBRE_EMISORA,
            CASE 
              WHEN h.ID_PRODUCTO IN ({REPORTO_RV_CSV}) THEN 2
              ELSE e.ID_TIPO_ACTIVO
            END AS ID_ACTIVO_LOGICO,
            SUM(h.VALOR_REAL) AS MONTO
          FROM SIAPII.V_HIS_POSICION_CLIENTE h
          JOIN SIAPII.V_M_CONTRATO_CDM c ON c.ID_CLIENTE = h.ID_CLIENTE AND c.ALIAS_CDM = :alias
          JOIN SIAPII.V_M_EMISORA e ON e.ID_EMISORA = h.ID_EMISORA
          WHERE h.REGISTRO_CONTROL >= ADD_MONTHS(TRUNC(SYSDATE,'MM'), -12)
          GROUP BY TRUNC(h.REGISTRO_CONTROL,'MM'),
                   e.NOMBRE_EMISORA,
                   CASE 
                     WHEN h.ID_PRODUCTO IN ({REPORTO_RV_CSV}) THEN 2
                     ELSE e.ID_TIPO_ACTIVO
                   END
        ),
        RV_MES AS (
          SELECT MES, SUM(MONTO) AS TOT_RV
          FROM H
          WHERE ID_ACTIVO_LOGICO = 2
          GROUP BY MES
        )
        SELECT H.MES, H.NOMBRE_EMISORA, H.ID_ACTIVO_LOGICO, H.MONTO, R.TOT_RV
        FROM H JOIN RV_MES R ON R.MES = H.MES
        WHERE H.ID_ACTIVO_LOGICO = 2
    """, {"alias": ALIAS_CDM})
    if rv12.empty:
        st.info("Sin datos para evolución 12 meses de RV.")
        return
    core = core_issuer_map()
    rv_m = rv12.merge(core, left_on="NOMBRE_EMISORA", right_on="issuer_name", how="left")
    rv_m["sector"] = rv_m["sector"].fillna("SIN SECTOR")
    rv_m["industry"] = rv_m["industry"].fillna("SIN INDUSTRIA")
    rv_m["PctPort"] = (rv_m["MONTO"] / rv_m["TOT_RV"] * 100.0).round(4)
    sec_rank = rv_m.groupby("sector")["PctPort"].sum().sort_values(ascending=False).head(3).index.tolist()
    rv_sec = rv_m[rv_m["sector"].isin(sec_rank)].copy()
    piv_sec = rv_sec.pivot_table(index="MES", columns="sector", values="PctPort", aggfunc="sum").fillna(0)
    piv_sec = piv_sec[piv_sec.mean(axis=0).sort_values(ascending=False).index]
    ind_rank = rv_m.groupby("industry")["PctPort"].sum().sort_values(ascending=False).head(3).index.tolist()
    rv_ind = rv_m[rv_m["industry"].isin(ind_rank)].copy()
    piv_ind = rv_ind.pivot_table(index="MES", columns="industry", values="PctPort", aggfunc="sum").fillna(0)
    piv_ind = piv_ind[piv_ind.mean(axis=0).sort_values(ascending=False).index]
    fig_sec = go.Figure()
    for col in piv_sec.columns:
        fig_sec.add_trace(go.Scatter(
            x=piv_sec.index, y=piv_sec[col], mode="lines", name=str(col),
            hovertemplate="%{x|%Y-%m}: %{y:.2f}%<extra></extra>"
        ))
    fig_sec.update_layout(
        title="3 Sectores",
        yaxis=dict(title="% de RV", ticksuffix="%"),
        xaxis=dict(title="Mes", tickangle=TICKANGLE),
        legend=LEGEND_RIGHT,
        paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=220, t=42, b=6), height=BARH_H
    )
    fig_ind = go.Figure()
    for col in piv_ind.columns:
        fig_ind.add_trace(go.Scatter(
            x=piv_ind.index, y=piv_ind[col], mode="lines", name=str(col),
            hovertemplate="%{x|%Y-%m}: %{y:.2f}%<extra></extra>"
        ))
    fig_ind.update_layout(
        title="3 Industrias",
        yaxis=dict(title="% de RV", ticksuffix="%"),
        xaxis=dict(title="Mes", tickangle=TICKANGLE),
        legend=LEGEND_RIGHT,
        paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)",
        margin=dict(l=10, r=220, t=42, b=6), height=BARH_H
    )
    c1, c2 = st.columns(2)
    with c1:
        st.plotly_chart(fig_sec, use_container_width=True, config={"displayModeBar": False})
    with c2:
        st.plotly_chart(fig_ind, use_container_width=True, config={"displayModeBar": False})

def render_rv_rendimientos_por_producto():
    st.subheader("Rendimientos por estrategia de renta variable")
    if df_hist_rend_prod is None or df_hist_rend_prod.empty:
        st.info("Sin rendimientos por producto disponibles.")
        return
    prod_act = df_aa_producto[["PRODUCTO","ACTIVO"]].drop_duplicates()
    df = df_hist_rend_prod.merge(prod_act, left_on="PRODUCTO", right_on="PRODUCTO", how="left")
    df = df[df["ACTIVO"] == "Renta Variable"]
    if df.empty:
        st.info("No hay productos de renta variable con rendimientos.")
        return
    productos = sorted(df["PRODUCTO"].unique().tolist())
    prod_sel = st.selectbox("Estrategia RV", options=productos, index=0)
    modo = st.radio("Tipo de rendimiento", ["Anualizado","Efectivo"], horizontal=True, key="rend_rv_prod")
    plot_rend_producto_series(df, prod_sel, modo, "Rendimientos brutos")

# =========================
#  TABS
# =========================
if not print_mode:
    tabs = st.tabs(["Resumen", "Asset Allocation", "Deuda", "Renta Variable"])

    with tabs[0]:
        st.container().markdown('<div class="tabs-normal"></div>', unsafe_allow_html=True)
        render_resumen()

    with tabs[1]:
        st.container().markdown('<div class="tabs-normal"></div>', unsafe_allow_html=True)
        sub = st.tabs(["Nivel Contrato", "Nivel producto", "Histórico"])
        with sub[0]:
            render_allocation_general()
        with sub[1]:
            render_allocation_detalle()
        with sub[2]:
            render_allocation_historico()

    with tabs[2]:
        st.container().markdown('<div class="tabs-normal"></div>', unsafe_allow_html=True)
        if df_final_deuda.empty:
            resumen_vals = { "Instrumentos":"0", "Valor mercado":"$0.00", "Duración (días)":"", "DxV (pond.)":"", "Rto. esperado 1 año":"" }
        else:
            mask_det = df_final_deuda['Instrumento'].astype(str).str.upper() != 'TOTAL'
            valor_mercado = money_to_float_series(df_final_deuda.loc[mask_det, 'Monto']).sum() if len(df_final_deuda) else 0.0
            total_row = df_final_deuda.iloc[-1] if len(df_final_deuda) else None
            resumen_vals = {
                "Instrumentos": f"{int(mask_det.sum()):,}",
                "Valor mercado": f"${valor_mercado:,.2f}",
                "Duración (días)": "" if total_row is None else str(total_row['Duración (días)']),
                "DxV (pond.)": "" if total_row is None else str(total_row['DxV']),
                "Rto. esperado 1 año": "" if total_row is None else str(total_row['Carry (365 d)']),
            }
        st.markdown('<div class="kpi-grid">' + "".join(
            f'<div class="kpi-card"><div class="kpi-label">{k}</div><div class="kpi-value">{v}</div></div>'
            for k,v in resumen_vals.items()
        ) + '</div>', unsafe_allow_html=True)

        sub = st.tabs(["Composición", "Riesgo", "Histórico", "Detalle", "Composicion por producto", "Rendimientos"])
        with sub[0]:
            render_deuda_composicion(df_final_deuda)
        with sub[1]:
            render_deuda_riesgo(df_final_deuda)
        with sub[2]:
            render_deuda_historico_trimestral()
        with sub[3]:
            render_deuda_tabla(df_final_deuda)
        with sub[4]:
            render_deuda_por_producto_comp(df_final_deuda)
        with sub[5]:
            render_deuda_rendimientos_por_producto()

    with tabs[3]:
        st.container().markdown('<div class="tabs-normal"></div>', unsafe_allow_html=True)
        sub = st.tabs(["Nivel Activo", "Nivel Producto", "Histórico", "Rendimientos"])
        with sub[0]:
            render_rv_resumen()
        with sub[1]:
            render_rv_por_producto()
        with sub[2]:
            render_rv_evolucion()
        with sub[3]:
            render_rv_rendimientos_por_producto()

else:
    st.markdown('<div class="print-container">', unsafe_allow_html=True)

    # 🔹 RESUMEN: sin clase print-section, por eso NO tiene salto previo
    st.header("Resumen")
    render_resumen()

    # 🔹 ASSET ALLOCATION: sí tiene salto de página antes
    st.markdown('<div class="print-section">', unsafe_allow_html=True)
    st.header("Asset Allocation")
    render_allocation_general()
    render_allocation_detalle()
    render_allocation_historico()
    st.markdown('</div>', unsafe_allow_html=True)

    # 🔹 DEUDA
    st.markdown('<div class="print-section">', unsafe_allow_html=True)
    st.header("Deuda")
    render_deuda_composicion(df_final_deuda)
    render_deuda_riesgo(df_final_deuda)
    render_deuda_historico_trimestral()
    render_deuda_tabla(df_final_deuda)
    render_deuda_por_producto_comp(df_final_deuda)
    render_deuda_rendimientos_por_producto()
    st.markdown('</div>', unsafe_allow_html=True)

    # 🔹 RENTA VARIABLE
    st.markdown('<div class="print-section">', unsafe_allow_html=True)
    st.header("Renta Variable")
    render_rv_resumen()
    render_rv_por_producto()
    render_rv_evolucion()
    render_rv_rendimientos_por_producto()
    st.markdown('</div>', unsafe_allow_html=True)

    st.markdown('</div>', unsafe_allow_html=True)


st.markdown("<hr/><div style='text-align:center;opacity:.85'><small>Datos al cierre del mes seleccionado</small></div>", unsafe_allow_html=True)
